#!/bin/bash
#
#
# =======================================================================================
#  This File Contains Global Variables and Public Functions Used by EMINFO and Plugins. 
# =======================================================================================
#
#



# BASE_DIR DEF
#[ -z ${BASE_DIR} ] && {
#  	path=$( cd $(dirname $0) && pwd)
#  	BASE_DIR=${path%/*}
#}
BASE_DIR="/usr/local/eminfo"




####################################
#				   #
#  --*--< Global Variables >--*--  #
#			           #
####################################

# VER DEF
EMINFO_VERSION="1.0-beta6"

# DIR DEF
BIN_DIR="${BASE_DIR}/bin"
CONF_DIR="${BASE_DIR}/conf"
HANDLER_DIR="${BASE_DIR}/handler"
OPT_DIR="${BASE_DIR}/opt"
PLUGIN_DIR="${BASE_DIR}/plugin"
INNER_DIR="${PLUGIN_DIR}/.inner"
TMP_DIR="${BASE_DIR}/tmp"
RUN_DIR="${TMP_DIR}/run"
LOG_DIR="${BASE_DIR}/log"
BACK_DIR="${LOG_DIR}/backup"
SNAPSHOT_DIR="${LOG_DIR}/snapshot"

# SH DEF
PRECHECK_SH="${BIN_DIR}/precheck"
UPDATE_SH="${BIN_DIR}/update"
REPORT_SH="${BIN_DIR}/report"
CHECKCONF_SH="${BIN_DIR}/checkconf"
POSTLOG_SH="${HANDLER_DIR}/postlog"
TAKESNAP_SH="${HANDLER_DIR}/takesnap"
SENDMAIL="${HANDLER_DIR}/sendmail"
SENDEMAIL="${OPT_DIR}/sendEmail"
MAKEDIR_SH="${BIN_DIR}/makedir"
SETINIT_SH="${BIN_DIR}/setinit"

# PERL UTIL DEF
PLUTIL="${BIN_DIR}/util.pl"

# LOG DEF
EMINFO_LOG="${LOG_DIR}/eminfo.log"
INNER_LOG="${LOG_DIR}/inner.log"
PRECHECK_LOG="${LOG_DIR}/precheck.log"
POSTLOG_LOG="${LOG_DIR}/postlog.log"
TAKESNAP_LOG="${LOG_DIR}/takesnap.log"
UPDATE_LOG="${LOG_DIR}/update.log"
SENDMAIL_LOG="${LOG_DIR}/sendmail.log"
ERRLOG="${LOG_DIR}/error.log"

# CFG DEF
CONFIG_FILE="${CONF_DIR}/.eminfo.ini"

# INC DEF
INCLUDE_FILE="${BIN_DIR}/include"

# PID DEF
PID_FILE="/var/run/eminfo.pid"

# TMP FILE DEF
TMP_LASTRUN="${TMP_DIR}/.lastrun.dat"
TMP_NEXTRUN="${TMP_DIR}/.nextrun.dat"
TMP_REPEAT="${TMP_DIR}/.repeat.dat"
TMP_STATUS="${TMP_DIR}/.status.dat"
SMTPHOST_STATUS="${TMP_DIR}/.smtphost.status"
POSTHOST_STATUS="${TMP_DIR}/.posthost.status"

# OTHER FILE DEF
PINYIN_FILE="${OPT_DIR}/pinyin.txt"


### POSTDATA SPLIT
SPLIT="#EMINFO#"


### PLUGIN BASE CONFIG NAME
ARRAY_BASE_CONFIG=(
  enable
  comment
  frequency
  exec_tmout
  maxerr_times
  take_snapshot
  mail_notify
  post_notify
  mail_receviers
  attsnap_mail
  auto_handle
  auto_handler
  debug
)

### PLUGIN RETRUN CODE MAPS
ARRAY_RCSTATUS_MAPS=(
  0 succ
  1 warn
  2 crit
  3 unkn
  4 noop
)


####################################
#				   #
#  --*--< Public Functions >--*--  #
#				   #
####################################



# Terminal color
echo_green() {
  local content=$*
  echo -e "\033[1;32m${content}\033[0m\c "
}
echo_yellow() {
  local content=$*
  echo -e "\033[1;33m${content}\033[0m\c "
}
echo_red() { 
  local content=$* 
  echo -e "\033[1;31m${content}\033[0m\c "
}

# HTML color
html_green() {
  local content=$*
  echo -e "<font color=green>${content}</font> \c "
}
html_yellow() {
  local content=$*
  echo -e "<font color=yellow>${content}</font> \c "
}
html_red() {
  local content=$*
  echo -e "<font color=red>${content}</font> \c "
}

# Random Number in specified range
# Usage:	random_num  min  max
#
random_num() {
  local min=$1 max=$2 tmp=$(echo "$2-$1" | bc 2>&-) base=$(date +%N%s)
  echo "${base} % ${tmp} + ${min} " | bc 2>&-
}

# $1 contains $2 or not
# Usage:	sub_str "strings" "str"
#
sub_str() {  
  [ "${1#*$2*}" == "$1" ] && echo no || echo yes  
}

# Write log
# Usage1:	1: set {_LOG} and ${_DEBUG} before you call this function.
# Usage2:	2: -f path/to/log/file     Note: this pattern will ignore ${_DEBUG} flag.
# Example1:	export _LOG=/tmp/log DEBUG=1 && write_log any stuff you want to log && unset _LOG
# Example2:	write_log -f /tmp/log  any stuff you want to log.
#
write_log() {
  local logfile=  content=
  [ "$1" == "-f" ] && {
	logfile="$2" ; shift 2
	content=$*
  } || {
  	[ "${_DEBUG}" != "1" ] && return 0
  	[ -z "${_LOG}" ] &&  logfile="${EMINFO_LOG}" || logfile="${_LOG}"
 	content=$*
  }
  echo "$(date +%s)" "$(date +%F_%T)" "${content}"  >> ${logfile} 2>&-
}

# Convert multi-link-path to real-path ( using python os.path.realpath )
# Usage:	py_conv_2realpath /path/to/somewhere
# Example:      py_conv_2realpath /link_1/link_2/link_3/link_filenam
#
py_conv_2realpath() {
  local f=$1  result=
  result=$( python -c "import os; print os.path.realpath('${f}')" 2>&- )
  echo -e "${result}"
}

# Convert multi-link-path to real-path
# Return: 	0 1 2 		realpath | relative link path | broken path
# Usage:	conv_2realpath  /path/to/somewhere
# Example:	conv_2realpath  /link_1/link_2/link_3/link_filename
#
# Sorry, Can NOT deal with: non-absolute link
#
conv_2realpath() {
  local f=$1
  local org="${f}"

  ### deal with broken path
  [ ! -e "${f}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 conv_2realpath broken path:"\
		"[${f}] broken at: [${f}]";
	return 2
  }
  
  until [ ! -L "${f}" ] 
  do
	f=$(readlink "${f}")
  done 

  local d= b=
  local arr=()

  b=$(basename "${f}")
  arr=( ${arr[@]} ${b} )
  d=$(dirname "${f}")
  until [ "${d}" == "/" ]; do
  	if [ -L "${d}" ]; then
		d=$(readlink "${d}")
  	else
		### deal with non-absolute path
		[ "${d}" == ".." -o "${d}" == "." -o "$(echo -e "${d}" |grep -E -o "\.\.\/|\.\/")" != "" ] && {
			write_log -f "${EMINFO_LOG}" "E0000000 conv_2realpath relative link path:"\
				"[${d}]";
			return 1
		}
		### deal with broken path
		[ ! -d "${d}" ] && {
			write_log -f "${EMINFO_LOG}" "E0000000 conv_2realpath broken path:"\
				"[${d}] broken at: [${d}]";
			return 2
		}
		b=$(basename "${d}")
		arr=( ${arr[@]} ${b} )
		d=$(dirname "${d}")
  	fi
  done

  for ((i=${#arr[@]};i>0;i--))
  do
	echo -ne "${arr[$i]}/"
  done
  echo -e "${arr[0]}"

  return 0
}

# According to input pidfile, output process state.
# Usage:	check_ps_on_pid_file  {pid_file}
# Return: 	0 1 2 3  ==>  Running | Missing arguments | Dead but pid file exists | Dead
#
check_ps_by_pid_file() {
  local pid_file=$1  pid=
  [ -z "${pid_file}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 check_ps_by_pid_file error:"\
		 "missing arguments, fpid=[${fpid}]";
	return 1
  }
  [ -f "${pid_file}" -a -s "${pid_file}" ] && {
  	read line < ${pid_file}
	for x in `echo ${line}`; do
  		[ -z "${x//[0-9]/}" -a -d "/proc/${x}" ] && pid="${pid} ${x}"
  	done
  	[ ! -z "${pid//[ ]}" ] && return 0 || return 2
  }
  return 3
}

# According to input ppid, search all of kid pids, output by reverse order.
# Usage:        get_pidkids_bypid {father_pid}
# Example:      get_pidkids_bypid 1876
#
get_pidkids_bypid() {
  local father_pid=$1
  local array_result=()
  # if empty, pstree will output all kid pids of init(1)
  [ -z "${father_pid}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 get_pidkids_bypid error:"\
		"missing arguments, father_pid=[${father_pid}]";
	return 2
  }
  if [ -z "${father_pid//[0-9]}" ]; then
	array_result=( $(/usr/bin/pstree -p ${father_pid} |\
			 grep -E -o "\([0-9]+\)" |\
			 tr -d '[\(\)]' | tail -n +2 |\
			 tr '\n\r' ' ') )
  else
	write_log -f "${EMINFO_LOG}" "E0000000 get_pidkids_bypid error:"\
		"input father_pid must be interger: [${father_pid}]";
	return 1
  fi
  
  for ((i=${#array_result[@]}-1;i>=0;i--))  ; do
     echo -n "${array_result[$i]} "
  done
  unset array_result
}

# According to input ppid, output kids number
# Usage:	get_kidsnum {father_pid}
# Example:	get_kidsnum 1876
#
get_kidsnum() {
  local father_pid=$1
  local result=
  # if empty, pstree will output all kid pids of init(1)
  [ -z "${father_pid}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 get_kidsnum error:"\
                "missing arguments, father_pid=[${father_pid}]";
        return 2
  }
  if [ -z "${father_pid//[0-9]}" ]; then
	result=$(/usr/bin/pstree -p ${father_pid} | grep -E -o -c "\([0-9]+\)")
  else
	write_log -f "${EMINFO_LOG}" "E0000000 get_kidsnum error:"\
		"input father_pid must be interger: [${father_pid}]";
	return 1
  fi
  echo "${result}"
}

# Check the file is plugin config file or not, retun plugin-name if valid file.
# Conditions: 
#   1. filename like {plugin-name}.ini
#   2. headline of file like  [plugin-name]
#   3. filesize must less than 1048576 bytes.(1M)
#   4. filetype must be like Text
# Output:  plugin-name | no  (blank space will be trimed)
# Example:  is_plugin_conifgfile "/dev/mcelog"
# Example:  is_plugin_configfile "/etc/abc.ini"
#
is_plugin_configfile(){
  local filepath=$1  result=
  local ftype=$(echo "${filepath}" | LANG=C perl -ne 'chomp;print -T "$_"?"text":"nontext";' 2>&-)
  if [ "${ftype}" != "text" ]; then
	result="no"
  else
	local fsize=$(echo "${filepath}" | LANG=C perl -ne 'chomp;$size=-s;print "$size"' 2>&-)
  	if [ -z "${fsize}" -o ! -z "${fsize//[0-9]}" ]; then
		result="no"
  	elif [ ${fsize} -ge 1048576 ]; then
		result="no"
	else
  		local pname=$(echo "${filepath##*/}" |LANG=C perl -ne 'if(m/\A(\S+)\.ini\Z/i){print "$1"};' 2>&-)
  		local hname=$(head -n1 "${filepath}" |LANG=C perl -ne 'if(m/\A\s*\[\s*(.+)\s*\]\s*/){print "$1"};' 2>&-)
  		if [ -z "${pname}" -o -z "${hname}" ]; then
			result="no"
  		elif [ "${pname}" != "${hname}" ]; then
			result="no"
  		else
			result="${pname}"
		fi
	fi
  fi
  echo "${result}"
}

# List all registered plugins exclude inners.  		
# Note: 	blank space will be trimed
#
list_plugin_section() {
  local config_files_arr=  result=
  config_files_arr=( $(ls "${CONF_DIR}/"*.ini 2>&-) )
  for((i=0;i<=${#config_files_arr[*]};i++));
  do
	filepath="${config_files_arr[$i]}"
	[ "${filepath##*/}" == "" ] && continue
	[ "${filepath##*/}" == ".eminfo.ini" ] && continue
	pluginname="$(is_plugin_configfile "${filepath}")"
	if [ "${pluginname}" != "no" ]; then
		[ ! -z "${result}" ] && result="${result} ${pluginname}" || result="${pluginname}"
	fi
  done
  echo "${result}"
}

# List all inner plugins.		
# Note: 	blank space will be trimed
#
list_inner_plugin_section() {
  local result=
  # Do NOT pass widechars such as chinese input to sed, which will lead to hangup in some circumstances.
  result=$( cat ${CONFIG_FILE} | grep -E -v "^[ \t]*;" | tr -d ' \t' |\
		sed -e '/^\[eminfo_.*\]$/!d; s/^\[//; s/\]$//;' |\
		tr '\r\n' ' ')
  echo "${result}"
}

# List all section name.
# Note: 	blank space will be trimed
#
list_all_section() {
  local result=
  # Do NOT pass widechars such as chinese input to sed, which will lead to hangup in some circumstances.
  result=$( cat ${CONFIG_FILE} | grep -E -v "^[ \t]*;" | tr -d ' \t' |\
  		sed -e '/^\[.*\]$/!d;/^\[[ \t]*\]$/d;s/^\[//;s/\]$//;' |\
  		tr '\r\n' ' ')
  result="${result} $(list_plugin_section)"
  echo "${result}"
}

# List single section's key name
#
list_section_keys(){
  local section=$1  result=  config_file=
  [ -z "${section}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 list_section_keys error:"\
		"missing section name";
        return 1
  }
  if [ "${section}" == "global" -o "${section}" == "default" ]; then
	config_file="${CONFIG_FILE}"
  elif [ "${section}" == "sendmail" -o "${section}" == "postlog" -o "${section}" == "takesnap" ]; then
	config_file="${CONFIG_FILE}"
  elif [ "$(echo "${section}" | grep -E -o "^eminfo_")" != "" ]; then
	config_file="${CONFIG_FILE}"
  else
	config_file="${CONF_DIR}/${section}.ini"
  fi
  [ -f "${config_file}" -a -s "${config_file}" ] || {
	write_log -f "${EMINFO_LOG}" "E0000000 list_section_keys error:"\
		"section=[${section}] config file [${config_file}] not exists or empty.";
	return 1
  }
  result=$(cat ${config_file} | tr '\t' ' ' |\
		awk -F "=" '\
			($0~/^ *\[ *'${section}' *\] *$/){k=1;x=1;next} \
			( x==1 && $0~/^ *\[ *.* *\] *$/ && $0!~/^ *\[ *'${section}' *\] *$/ ){exit} \
			(k==1 && x==1 && $0!~/^[ \t]*$/ && $0!~/^[ \t]*;/){print $1}' |\
		sed -e 's/^[ \t]*//; s/[ \t]*$//; s/^\"//; s/\"$//')
  echo -e "${result}"
}

# According to input plugin-name, output matched plugin-name in plugin config file.
# Example:	read_plugin_section  check_sysload
# Return:	0 1:  OK | Missing arguments
#
read_plugin_section(){
  local section=$1
  if [ -z "${section}" ]; then 
	write_log -f "${EMINFO_LOG}" "E0000000 read_plugin_section error:"\
		"missing arguments, section=[${section}]";
	return 1
  else
        config_file="${CONF_DIR}/${section}.ini"
	if [ "$(is_plugin_configfile "${config_file}")" == "${section}" ]; then
		echo "${section}"
		return 0
	fi
  fi
}

# According to input section-name, output matched section-name in eminfo config file.
# Example:	read_eminfo_section   eminfo_iam_alive
# Return:	0 1 2 3 :  OK | Missing arguments | ${config_file} empty / not exist | Null
#
read_eminfo_section() {
  local section=$1  value= config_file=
  if [ -z "${section}" ]; then 
        write_log -f "${EMINFO_LOG}" "E0000000 read_eminfo_section error:"\
                "missing arguments, section=[${section}]";
        return 1
  else 
	config_file="${CONFIG_FILE}"
        if [ ! -f "${config_file}" -o ! -s "${config_file}" ]; then 
                write_log -f "${EMINFO_LOG}" "E0000000 read_eminfo_section error:"\
                        "config file [${config_file}] not exists or empty.";
                return 2
        else 
                value=$(cat ${config_file} |\
                        grep -E -v "^[ \t]*;" | tr -d ' \t' |\
                        sed -e '/^\['${section}'\]$/!d; s/^\[//; s/\]$//;')
                if [ -n "${value}" ]; then 
                        echo "${value}" 
                        return 0
                else 
                        return 3
                fi   
        fi   
  fi
}

# According to input plugin-name config-name, output matched config-value in config file.
# Usage:  	read_eminfo_config {plugin-name} {config-name}
# Example:  	read_eminfo_config check_sysload  enable
# Return:	0 1 2 3 :  OK | Missging arguments | ${config_file} empty / not exist | Null
#
read_eminfo_config(){
  local section=$1  key=$2  value=  config_file=
  if [ -z "${section}" -o -z "${key}" ]; then
	write_log -f "${EMINFO_LOG}" "E0000000 read_eminfo_config error:"\
		"missing arguments, section=[${section}] key=[${key}]";
	return 1
  else
	if [ "${section}" == "global" -o "${section}" == "default" ]; then 
        	config_file="${CONFIG_FILE}"
	elif [ "${section}" == "sendmail" -o "${section}" == "postlog" -o "${section}" == "takesnap" ]; then
		config_file="${CONFIG_FILE}"
  	elif [ "$(echo "${section}" | grep -E -o "^eminfo_")" != "" ]; then
        	config_file="${CONFIG_FILE}"
  	else 
        	config_file="${CONF_DIR}/${section}.ini"
  	fi

	if [ -f "${config_file}" -a -s "${config_file}" ]; then
		###  Notice:  \s NOT match : []space
  		value=$( cat ${config_file} | tr '\t' ' ' |\
			awk -F "=" '\
				($0~/^ *\[ *'${section}' *\] *$/){k=1;x=1;next}\
				( x==1 && $0~/^ *\[ *.* *\] *$/ && $0!~/^ *\[ *'${section}' *\] *$/ ){exit}\
				( k==1 && x==1 && $1~/^'${key}'\>/ ){$1="";print;exit}' |\
			 sed -e 's/^[ \t]*//; s/[ \t]*$//; s/^\"//; s/\"$//' )
		if [ -n "${value}" ]; then
			echo "${value}" && return 0 
		else
			# this may lead to plenty of log records in {EMINFO_LOG}
			# write_log -f "${EMINFO_LOG}" E0000000 read_eminfo_config error: "[${section}.${key}]" return NULL.
			return 3
		fi
	else
		write_log -f "${EMINFO_LOG}" "E0000000 read_eminfo_config error:"\
			"config file [${config_file}] not exists or empty.";
		return 2
	fi
  fi
}

# According to exist plugin-name/key and input value, update matched value in config file.
# Usage:	update_eminfo_config [force] {plugin-name} {config-name} {value}
# Example:	update_eminfo_config 	       check_sysload enable no
# Return:	
# 0 : Update OK
# 1 : Update ERROR
# 2 : No Need, Nothing to do (nower value equals what you want to set)
# 3 : Missging arguments
# 4 : ${config_file} empty / not exist 
# 5 : [section].key not exist
# 9 : WARN -> update global.id global.name
# LogFlag:      CHNG0000
# 
update_eminfo_config() {
  local mode=$1 
  if [ "${mode}" == "force" ]; then   ### only called by bin/setinit
 	local section=$2 key=$3 ; shift 3 ; local value=$*
  else
  	local section=$1 key=$2 ; shift 2 ; local value=$*
  fi
  local errinfo=  config_file=
  if [ -z "${section}" -o -z "${key}" -o -z "${value}" ]; then
        write_log -f "${EMINFO_LOG}" "E0000000 update_eminfo_config error:"\
		"missing arguments, section=[${section}] key=[${key}] value=[${value}]";
        return 3
  else
	# return 9(warn) if global.id global.name
	if [ "${section}" == "global" -a "${key}" == "id" -a "${mode}" != "force" ]; then
		return 9
	elif [ "${section}" == "global" -a "${key}" == "name" -a "${mode}" != "force" ]; then
		return 9
	fi
	# set config_file
	if [ "${section}" == "global" -o "${section}" == "default" ]; then 
        	config_file="${CONFIG_FILE}"
        elif [ "${section}" == "sendmail" -o "${section}" == "postlog" -o "${section}" == "takesnap" ]; then
		config_file="${CONFIG_FILE}"
  	elif [ "$(echo "${section}" | grep -E -o "^eminfo_")" != "" ]; then
        	config_file="${CONFIG_FILE}"
  	else 
        	config_file="${CONF_DIR}/${section}.ini"
  	fi

	if [ -f "${config_file}" -a -s "${config_file}" ]; then
  		local linenum=$( cat ${config_file} | tr '\t' ' ' |\
				 awk -F"=" '\
					($0~/^ *\[ *'${section}' *\] *$/){k=1;x=1;next}\
					( x==1 && $0~/^ *\[ *.* *\] *$/ && $0!~/^ *\[ *'${section}' *\] *$/ ){exit}\
					( k==1 && x==1 && $1~/^'${key}'\>/ ){print NR;exit;}' )
  		if [ -z "${linenum}" ]; then
			write_log -f "${EMINFO_LOG}" "CHNG0000 update_eminfo_config notice:"\
				"section=[${section}] key=[${key}] not found in config file."
			return 5
  		else
			local nowvalue=$(read_eminfo_config "${section}" "${key}")
			if [ "${value}" != "${nowvalue}" ]; then
				write_log -f "${EMINFO_LOG}" "CHNG0000 update_eminfo_config notice:"\
					"section=[${section}] key=[${key}] found in config file,"\
					 "line-number=[${linenum}], nower value=[${nowvalue}],"\
					 "trying to change as [${value}]"
			else
				write_log -f "${EMINFO_LOG}" "CHNG0000 update_eminfo_config notice:"\
					"section=[${section}] key=[${key}] found in config file,"\
					"line-number=[${linenum}], nower value=[${nowvalue}],"\
					"no need to change as [${value}], nothing to do."
				return 2
			fi
                        ### '"${value}"' is important, if ${value} is multi part or cotains invalid chars, sed won't complain
                        ### '${value}' is wrong.
			### sed command c to replace the whole line.
			errinfo=$(\
			    sed -i ''${linenum}'c'"${key}"' = '"${value}"'' "${config_file}" 2>&1 1>/dev/null)
			if [ "$?" == "0" ]; then
				write_log -f "${EMINFO_LOG}" "CHNG0000 update_eminfo_config change"\
					"section=[${section}] key=[${key}] value=[${value}] line-number=[${linenum}]"\
					"success"
				return 0
			else
				write_log -f "${EMINFO_LOG}" "CHNG0000 update_eminfo_config error:"\
					"section=[${section}] key=[${key}] value=[${value}] line-number=[${linenum}]"\
					"errinfo=[${errinfo}]" 
				return 1
			fi
  		fi
	else
		write_log -f "${EMINFO_LOG}" "E0000000 update_eminfo_config error:"\
			"config file [${config_file}] not exists or empty.";
		return 4
	fi
  fi
}

# According to exist plugin-name and input key/value , add key = value into config file.
# Usage:        add_eminfo_config [force] {plugin-name} {config-name} {value}
# Example:      add_eminfo_config 	    check_sysload enable no
# Return:       
# 0 : ADD OK
# 1 : ADD ERROR
# 2 : No Need, Nothing to do (key already exist)
# 3 : Missging arguments
# 4 : ${config_file} empty / not exist 
# 5 : [section] not exist
# 9 : WARN -> add global.id global.name
# LogFlag:      ADDC0000
# 
add_eminfo_config() {
  local mode=$1 
  if [ "${mode}" == "force" ]; then   ### only called by bin/setinit
        local section=$2 key=$3 ; shift 3 ; local value=$*
  else 
        local section=$1 key=$2 ; shift 2 ; local value=$*
  fi
  local errinfo=  config_file=
  if [ -z "${section}" -o -z "${key}" -o -z "${value}" ]; then 
        write_log -f "${EMINFO_LOG}" "E0000000 add_eminfo_config error:"\
                "missing arguments, section=[${section}] key=[${key}] value=[${value}]";
        return 3
  else 
	# return 9(warn) if global.id global.name
	if [ "${section}" == "global" -a "${key}" == "id" -a "${mode}" != "force" ]; then
		return 9
	elif [ "${section}" == "global" -a "${key}" == "name" -a "${mode}" != "force" ]; then
		return 9
	fi
	# set config_file 
	if [ "${section}" == "global" -o "${section}" == "default" ]; then 
        	config_file="${CONFIG_FILE}"
        elif [ "${section}" == "sendmail" -o "${section}" == "postlog" -o "${section}" == "takesnap" ]; then
		config_file="${CONFIG_FILE}"
  	elif [ "$(echo "${section}" | grep -E -o "^eminfo_")" != "" ]; then
        	config_file="${CONFIG_FILE}"
  	else 
        	config_file="${CONF_DIR}/${section}.ini"
  	fi

	if [ -f "${config_file}" -a -s "${config_file}" ]; then
		local section_linenum=$( cat ${config_file} | tr '\t' ' ' |\
					awk '($0~/^ *\[ *'${section}' *\] *$/){print NR;exit;}' )
		if [ -z "${section_linenum}" ]; then
			write_log -f "${EMINFO_LOG}" "ADDC0000 add_eminfo_config notice:"\
				"section=[${section}] not found in config file."
                        return 5
		else
			local flag=0
			for k in `list_section_keys "${section}"`
			do
				if [ "${key}" != "${k}" ]; then
					continue
				else
					flag=1; break
				fi
			done
			if [ "${flag}" == "0" ]; then
                                write_log -f "${EMINFO_LOG}" "ADDC0000 add_eminfo_config notice:"\
                                        "key=[${key}] for section=[${section}] not found in config file,"\
                                        "trying to add config [${key}] for [${section}]"\
					"under line [${section_linenum}]"
			else
                                write_log -f "${EMINFO_LOG}" "ADDC0000 add_eminfo_config notice:"\
                                        "key=[${key}] for section=[${section}] already exists in config file,"\
                                        "no need to add config [${key}] for [${section}], nothing to do."
				return 2
			fi
			### '"${value}"' is important, if ${value} is multi part or cotains invalid chars, sed won't complain
			### '${value}' is wrong.
			### sed command a to add newline under specified line.
			errinfo=$(\
				sed -i ''${section_linenum}'a'"${key}"' = '"${value}"'' "${config_file}" 2>&1 1>/dev/null)
                        if [ "$?" == "0" ]; then 
                                write_log -f "${EMINFO_LOG}" "ADDC0000 add_eminfo_config add"\
                                        "config [${key} = ${value}] for section [${section}] under [${section_linenum}]"\
                                        "success"
                                return 0
                        else 
                                write_log -f "${EMINFO_LOG}" "ADDC0000 add_eminfo_config error: [${errinfo}]" 
                                return 1
                        fi
		fi
	else
                write_log -f "${EMINFO_LOG}" "E0000000 add_eminfo_config error:"\
                        "config file [${config_file}] not exists or empty.";
                return 4
	fi
  fi
}

# According to exist plugin-name and input key , delete plugin's key from config file.
# Usage:        del_eminfo_config {plugin-name} {config-name}
# Example:      del_eminfo_config check_sysload enable
# Return:
# 0 : DEL OK
# 1 : DEL ERROR
# 2 : No Need, Nothing to do (key already not exist)
# 3 : Missging arguments
# 4 : ${config_file} empty / not exist 
# 5 : [section] not exist
# 9 : WARN -> del global.id global.name
# LogFlag:	DELC0000
#
del_eminfo_config() {
  local section=$1 key=$2 config_file=
  local errinfo=
  if [ -z "${section}" -o -z "${key}" ]; then
        write_log -f "${EMINFO_LOG}" "DELC0000 del_eminfo_config error:"\
		"missing arguments, section=[${section}] key=[${key}]";
        return 3
  else
	# return 9(warn) if global.id global.name
	if [ "${section}" == "global" -a "${key}" == "id" ]; then
		return 9
	elif [ "${section}" == "global" -a "${key}" == "name" ]; then
		return 9
	fi
	# set config_file 
	if [ "${section}" == "global" -o "${section}" == "default" ]; then 
        	config_file="${CONFIG_FILE}"
        elif [ "${section}" == "sendmail" -o "${section}" == "postlog" -o "${section}" == "takesnap" ]; then
		config_file="${CONFIG_FILE}"
  	elif [ "$(echo "${section}" | grep -E -o "^eminfo_")" != "" ]; then
        	config_file="${CONFIG_FILE}"
  	else 
        	config_file="${CONF_DIR}/${section}.ini"
  	fi

	if [ -f "${config_file}" -a -s "${config_file}" ]; then
		local section_linenum=$( cat ${config_file} | tr '\t' ' ' |\
					awk '($0~/^ *\[ *'${section}' *\] *$/){print NR;exit;}' )
		if [ -z "${section_linenum}" ]; then 
			write_log -f "${EMINFO_LOG}" "DELC0000 del_eminfo_config notice:"\
				"section=[${section}] not found in config file."
			return 5
  		else
			local nowvalue=$(read_eminfo_config "${section}" "${key}")
			local flag=0
			for k in `list_section_keys "${section}"`
			do
				if [ "${key}" != "${k}" ]; then
					continue
				else
					flag=1; break
				fi
			done
			if [ "${flag}" == "1" ]; then
				write_log -f "${EMINFO_LOG}" "DELC0000 del_eminfo_config notice:"\
					"section=[${section}] key=[${key}] found in config file,"\
					 "line-number=[${linenum}], nower value=[${nowvalue}],"\
					 "trying to delete config [${key}]"
  				local linenum=$( cat ${config_file} | tr '\t' ' ' |\
				 	awk -F"=" '\
						($0~/^ *\[ *'${section}' *\] *$/){k=1;x=1;next}\
						( x==1 && $0~/^ *\[ *.* *\] *$/ && $0!~/^ *\[ *'${section}' *\] *$/ ){exit}\
						( k==1 && x==1 && $1~/^'${key}'\>/ ){print NR;exit;}' )
			else
				write_log -f "${EMINFO_LOG}" "DELC0000 del_eminfo_config notice:"\
					"section=[${section}] key=[${key}] not found in config file,"\
					"no need to delete it, nothing to do."
				return 2
			fi
			### sed command d to delete the whole line.
			errinfo=$(\
			    sed -i ''${linenum}'d' "${config_file}" 2>&1 1>/dev/null)
			if [ "$?" == "0" ]; then
				write_log -f "${EMINFO_LOG}" "DELC0000 del_eminfo_config delete"\
					"section=[${section}] key=[${key}] line-number=[${linenum}]"\
					"success"
				return 0
			else
				write_log -f "${EMINFO_LOG}" "DELC0000 del_eminfo_config error:"\
					"section=[${section}] key=[${key}] line-number=[${linenum}]"\
					"errinfo=[${errinfo}]" 
				return 1
			fi
  		fi
	else
		write_log -f "${EMINFO_LOG}" "DELC0000 del_eminfo_config error:"\
			"config file [${config_file}] not exists or empty.";
		return 4
	fi
  fi
}

# Get plugin status    config-name:  enable
# Note: if returned config-value is invalid, return no
#
get_enable() {
  local plugin_name=$1  result=
  [ -z "${plugin_name}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 get_enable error: missing plugin name";
	return 1
  }
  result=$(read_eminfo_config ${plugin_name} enable)
  [ -z "${result}" ] && result=$(read_eminfo_config default enable)

  # check valid or not
  [ -z "${result}" ] && {
	result="no"
  } || {
  	[ "${result}" != "yes" -a "${result}" != "no" ] && result="no"
  }
  echo "${result}"
}

# Get plugin debug	config-name:  debug
# Note: if returned config-value is invalid, return yes
#
get_debug() {
  local plugin_name=$1  result=
  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 get_debug error: missing plugin name";
        return 1
  }
  result=$(read_eminfo_config ${plugin_name} debug)
  [ -z "${result}" ] && result=$(read_eminfo_config default debug)
 
  # check valid or not
  [ -z "${result}" ] && {
        result="yes"
  } || {
        [ "${result}" != "yes" -a "${result}" != "no" ] && result="yes"
  }
  echo "${result}"
}

# Get plugin attsnap_mail config-name:  attsnap_mail
# Note: called by script: bin/sendmail
# Note: if returned config-value null or invalid, return yes
#
get_attsnap_mail() {
  local plugin_name=$1  result=
  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 get_attsnap_mail error: missing plugin name";
        return 1
  }

  result=$(read_eminfo_config ${plugin_name} attsnap_mail)
  [ -z "${result}" ] && result=$(read_eminfo_config default attsnap_mail)
  # check null or invalid or not
  [ -z "${result}" ] && {
 	result="yes"
  } || {
  	[ "${result}" != "yes" -a "${result}" != "no" ] && result="yes"
  }
  echo "${result}"
}

# Get plugin frequency    config-name: frequency
# Note: if returned config-value is invalid, return 30min
#
get_frequency() {
  local plugin_name=$1  result=  value=   min=30
  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 get_frequency error: missing plugin name";
        return 1
  }
  result=$(read_eminfo_config ${plugin_name} frequency)
  [ -z "${result}" ] && result=$(read_eminfo_config default frequency)

  # check valid or not
  value=$( conv_time2sec "${result}" )
  if [ "${value}" == "invalid" ]; then
	write_log -f "${EMINFO_LOG}" "E0000000 get_frequency on"\
		"[${plugin_name}]: return is invalid:"\
		"[${result}] ==> auto set to 30min.";
	result="30min"
  elif [ ! -z "${value}" -a -z "${value//[0-9]}" ]; then
	[ "$(echo "${value} < ${min}" | bc 2>&-)" == "1" ] && {
		write_log -f "${EMINFO_LOG}" "E0000000 get_frequency on"\
			"[${plugin_name}]: return [${result}] is smaller than minimum"\
			"==> auto set to 30sec";
		result="30sec"
	}
  fi
  echo "${result}"
}

# Get plugin execution timeout      config-name:  exec_tmout
# Note: if returned config-value is invalid. return 10min
# 
get_exec_tmout() {
  local plugin_name=$1  result=  value=
  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 get_exec_tmout error: missing plugin name";
        return 1
  }
  result=$(read_eminfo_config ${plugin_name} exec_tmout)
  [ -z "${result}" ] && result=$(read_eminfo_config default exec_tmout)

  # check valid or not
  value=$( conv_time2sec "${result}" )
  [ "${value}" == "invalid" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 get_exec_tmout on [${plugin_name}]:"\
		"return is invalid: [${result}]"\
		"==>auto set to 10min.";
        result="10min"
  }
  echo "${result}"
}

# Get plugin mail receviers	config-name:  mail_receviers
# called by script bin/sendmail
# Note: if returned email address is empty. return "root_bbk@126.com"
#
get_mail_receviers() {
  local plugin_name=$1  result=
  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 get_mail_receviers error: missing plugin name";
        return 1
  }
  result=$(read_eminfo_config ${plugin_name} mail_receviers)
  [ -z "${result}" ] && result=$(read_eminfo_config default mail_receviers)

  if [ -f "/${result##*file:}" -a -s "/${result##*file:}" ]; then
        result=$(awk '($0!~/^[ \t]*#/) { for(i=1;i<=NF;i++) {printf "%s ",$i} }' "/${result##*file:}")
  elif [ -f "${BASE_DIR}/${result##*file:}" -a -s "${BASE_DIR}/${result##*file:}" ]; then
        result=$(awk '($0!~/^[ \t]*#/) { for(i=1;i<=NF;i++) {printf "%s ",$i} }' "${BASE_DIR}/${result##*file:}")
  else
        [ -z "${result}" ] && result="root_bbk@126.com"  ### set default whatever.
  fi
  echo -en "${result}"
}

# Get plugin auto handler	config-name auto_handler
# called by process_plugin
#
get_auto_handler() {
  local plugin_name=$1  result=
  [ -z "${plugin_name}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 get_auto_handler error: missing plugin name";
	return 1
  }
  result=$(read_eminfo_config ${plugin_name} auto_handler)
  [ -z "${result}" ] && result=$(read_eminfo_config default auto_handler)
  echo -e "${result}"
}


# Get plugin comment		config-name:  comment
# Note: if returned config-value is empty. return "Eminfo Plugin"
#
get_comment() {
  local plugin_name=$1  result=  default="Eminfo Plugin"
  [ -z "${plugin_name}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 get_comment error: missing plugin name";
	return 1
  }
  result=$(read_eminfo_config ${plugin_name} comment)
  [ -z "${result}" ] && result=$(read_eminfo_config default comment)
  [ -z "${result}" ] && result="${default}"
  echo "${result}"
}

# Get global name		config-name:  name
# Note: if returned config-value is empty. return "eminfo_ops.eyou.net"
#
get_global_name() {
  local result=  default="eminfo_ops.eyou.net"
  result=$(read_eminfo_config global name)
  [ -z "${result}" ] && result="${default}"
  echo "${result}"
}

# Get eminfo id			config-name:  id
# Note: if returned config-value is empty. return "0000000000"
#
get_eminfo_id() {
  local result=  default="0000000000"
  result=$(read_eminfo_config global id)
  [ -z "${result}" ] && result="${default}"
  echo "${result}"
}

# Get plugin max repeat errtimes	config-name:  maxerr_times
# Note: if returned config-value is invalid. return 1
#
get_maxerr_times() {
  local plugin_name=$1  result=
  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 get_maxerr_times error: missing plugin name";
        return 1
  }
  result=$(read_eminfo_config ${plugin_name} maxerr_times)
  [ -z "${result}" ] && result=$(read_eminfo_config default maxerr_times)

  # check valid or not ==> ( 0 is invalid )
  [ -z "${result}" -o ! -z "${result//[1-9]}" ] && result=1  # set default whatever.
  echo "${result}"
}

# Get plugin's xxxx_action_type value.		
# allowed action_type ==> [ take_snapshot | mail_notify | post_notify | auto_handle ]
# Usage:      get_action_type  plugin-name  xxxx_action_type
# Example:	get_action_type  check_sysload mail_notify
# Note: invalid values will be ignored, only return valid values.
# Note: duplication items will be removed.
# Return:  1: plugin_name or action_type empty  2: action_type invalid
#
get_action_type() {
  local plugin_name=$1  action_type=$2
  local result=  output=  item=
  local valid_list=" crit warn unkn succ tmout all none default "
  [ -z "${plugin_name}" -o -z "${action_type}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 get_action_type error:"\
		"missing plugin_name or action_type : [$*]";
        return 1
  }
  [ "${action_type}" != "take_snapshot" -a "${action_type}" != "mail_notify" -a "${action_type}" != "post_notify" -a "${action_type}" != "auto_handle" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 get_action_type error:"\
		"action_type: [${action_type}] is invalid,"\
		"only [ take_snapshot/mail_notify/post_notify/auto_handle ] is acceptable.";
	return 2
  }

  ### read values
  result=$(read_eminfo_config ${plugin_name} ${action_type})
  [ -z "${result}" ] && result=$(read_eminfo_config default ${action_type})

  ### unfolder [all|default|none] and remove invalid values.
  for item in `echo "${result}"`
  do
	if [ "$(echo -e "${valid_list}"|grep -E -o -w "${item}")" == "${item}" ]; then  ### item valid
		case "${item}" in
		"all")
			output="${output} crit warn unkn succ tmout"	;;
		"default")
			output="${output} crit warn unkn tmout"		;;
		"none")
			output="none"  ### break while "none"
			break						;;
		*)
			output="${output} ${item}"
		esac	
	fi
  done

  ### remove duplication items.
  output=$(echo "${output}" | awk -vRS="[\n ]" -vORS=" " '!a[$0]++')
  echo "${output}"
}

# Take action or not
# Argument 1:  plugin-name
# Argument 2:  action_type => take_snapshot mail_notify post_notify auto_handle
# Argument 3:  event	=> 0 1 2 3 4 tmout
# Example:	take_action_ornot  check_sysload mail_notify 3
# Example:	take_action_ornot  check_v4_ps post_notify 0
# Example:	take_action_ornot  check_cpu_usage take_snapshot tmout
# 
take_action_ornot() {
  local plugin_name=$1  action_type=$2  event=$3
  local result=
  local valid_list=" crit warn unkn succ tmout all none default "
  [ -z "${plugin_name}" -o -z "${action_type}" -o -z "${event}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 take_action_ornot error:"\
		"missing plugin_name or action_type or event : [$*]";
        return 1
  }
  
  ### 1. read plugin_name action_type
  local action_type_config=$(get_action_type ${plugin_name} ${action_type})

  ### 2. event in actinon_type or not ? 
  local status=
  if [ "${event}" == "tmout" ]; then  ### 2.1 process event: tmout 
	[ "$(echo -e "${action_type_config}"|grep -E -o -w "${event}")" == "${event}" ] && {
		result="yes"
	} || {
		result="no"
	}
  else
  	for ((i=0;i<=${#ARRAY_RCSTATUS_MAPS[@]}-1;i++))  ### 2.2 process event: return_code
  	do
		[ "${ARRAY_RCSTATUS_MAPS[${i}]}" == "${event}" ] && {
			local i2=$((${i}+1))
			status=${ARRAY_RCSTATUS_MAPS[${i2}]}
			# echo "${i} ${i2} ${ARRAY_RCSTATUS_MAPS[${i2}]} ${action_type_config}"
			[ "$(echo -e "${action_type_config}"|grep -E -o -w "${status}")" == "${status}" ] && {
				result="yes"
			} || {
				result="no"
			}
			break
		}
  	done
	[ -z "${result}" ] && result="no"   ### if not matched, return no
  fi
  echo "${result}"
}

# Convert timelong to seconds
# Output:	seconds	| invalid
# Example:	conv_time2sec  30sec | 30seconds | 30min | 1hour | 1day | 2week | 3month | 4year | 2day5hour54sec
#
conv_time2sec(){
  local timelong=$1 result=
  local now=$(date +%s)
  local after=$(date -d "+${timelong}" +%s 2>&-)
  if [ ! -z "${after}" -a -z "${after//[0-9]}" ]; then
	result=$(echo "${after//[!0-9]} - ${now}" | bc 2>&-)
  else
	write_log -f "${EMINFO_LOG}" "E0000000 conv_time2sec error:"\
		"input invalid: ${timelong}";
	result="invalid"
  fi
  echo "${result}"
}

# Get timestamp of plugin last-run.
# Output:	never_run | invalid_lastrun | "timestamps of last run"
#
get_lastrun() {
  local plugin_name=$1  result=
  [ -z "${plugin_name}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 get_lastrun error: missing plugin name";
	return 1
  }
  if [ ! -s ${TMP_LASTRUN} ]; then
	result="never_run"
  else
  	result=$(awk '($1~/\<'${plugin_name}'\>/) {print $2;exit}' ${TMP_LASTRUN} 2>&-)
  	[ -z "${result}" ] && {
		result="never_run" 
	} || {
		[ ! -z "${result//[0-9]/}" ]  && result="invalid_lastrun"
	}
  fi
  echo "${result}"
}

# Get timestamp of plugin next-run.
# Output:	null | invalid_nextrun | "timestamps of next run"
#
get_nextrun() {
  local plugin_name=$1 result=
  [ -z "${plugin_name}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 get_nextrun error: missing plugin name";
	return 1
  }
  if [ ! -s ${TMP_NEXTRUN} ]; then
	result="null"
  else
	result=$(awk '($1~/\<'${plugin_name}'\>/) {print $2;exit}' ${TMP_NEXTRUN} 2>&-)
	[ -z "${result}" ] && {
		result="null"
	} || {
		[ ! -z "${result//[0-9]/}" ]  && result="invalid_nextrun"
	}
  fi
  echo "${result}" 
}

# Update timestamp of plugin last-run and next-run
# Note: 	only called on plugin finished.
# LogFlag:	CRIT0000 | 00000000
#
update_lastrun_and_nextrun() {
  local plugin_name=$1  rc=  errinfo=
  local now=$(date +%s) 
  local headline="NOTICE  --*--< DO NOT EDIT THIS FILE >--*-- \n\n"
  [ -z "${plugin_name}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 update_lastrun_and_nextrun error: missing plugin name";
	return 1
  }

  if [ -z "$( echo "${plugin_name}" | grep -E -o "^eminfo_" )" ]; then
	local logfile="${EMINFO_LOG}"
  else
	local logfile="${INNER_LOG}"                                                                                   
  fi

  touch ${TMP_LASTRUN} ${TMP_NEXTRUN}
  [ ! -s ${TMP_LASTRUN} ] && echo -e "${headline}" > ${TMP_LASTRUN}
  [ ! -s ${TMP_NEXTRUN} ] && echo -e "${headline}" > ${TMP_NEXTRUN}

  # Step 1: first update last-run
  # following sed command will lead to some repeat records.
  # sed -i '/^'${plugin_name}'\>/s/.*/'${plugin_name}' '${now}'/;tk;$s/$/\n'${plugin_name}' '${now}'/;:k'  ${TMP_LASTRUN}
  local l_time=$(awk '/^'${plugin_name}'\>/' ${TMP_LASTRUN} 2>&-)
  if [ -z "${l_time}" ]; then
	### only collect stderr output
	### '"${plugin_name}"' is important, sed won't complain if plugin_name contains multi part or special chars.
	errinfo=$( sed -i '$s/$/\n'"${plugin_name}"' '"${now}"'/' ${TMP_LASTRUN} 2>&1 1>/dev/null )
	rc=$?
	if [ "${rc}" != "0" ]; then
		write_log -f "${logfile}" "CRIT0000 update_lastrun_and_nextrun on plugin:"\
			"[${plugin_name}] for [empty, add new lastrun item as nower: ${now}]"\
			"error: [${errinfo}]";
	else
		write_log -f "${logfile}" "00000000 update_lastrun_and_nextrun on plugin:"\
			"[${plugin_name}] for [empty, add new lastrun item as nower: ${now}]"\
			"success";
	fi
  else
	### only collect stderr output
	### sed command c to replace the whole line.
	errinfo=$( sed -i '/^'"${plugin_name}"'\>/c'"${plugin_name}"' '"${now}"'' ${TMP_LASTRUN} 2>&1 1>/dev/null )
	rc=$?
	if [ "${rc}" != "0" ]; then
                write_log -f "${logfile}" "CRIT0000 update_lastrun_and_nextrun on plugin:"\
			"[${plugin_name}] for [update lastrun time as nower: ${now}]"\
			"error: [${errinfo}]";
	else
		write_log -f "${logfile}" "00000000 update_lastrun_and_nextrun on plugin:"\
			"[${plugin_name}] for [update lastrun time as nower: ${now}]"\
			"success";
	fi
  fi

  # Step 2: then read last-run and update next-run
  local lastrun=$(get_lastrun ${plugin_name})
  local frequency=$(get_frequency ${plugin_name})
  local nextrun=$(( ${lastrun} + $(conv_time2sec "${frequency}") ))
  # following sed command will lead to some repeat records.
  # sed -i '/^'${plugin_name}'\>/s/.*/'${plugin_name}' '${nextrun}'/;tk;$s/$/\n'${plugin_name}' '${nextrun}'/;:k' ${TMP_NEXTRUN}
  local n_time=$( awk '/^'${plugin_name}'\>/' ${TMP_NEXTRUN} 2>&-)
  if [ -z "${n_time}" ]; then
	### only collect stderr output
	### '"${plugin_name}"' is important, sed won't complain if plugin_name contains multi part or special chars.
        errinfo=$( sed -i '$s/$/\n'"${plugin_name}"' '"${nextrun}"'/' ${TMP_NEXTRUN} 2>&1 1>/dev/null )
	rc=$?
	if [ "${rc}" != "0" ]; then
                write_log -f "${logfile}" "CRIT0000 update_lastrun_and_nextrun on plugin:"\
			"[${plugin_name}] for [empty, add new nextrun item as ${nextrun}]"\
			"error: [${errinfo}]";
	else
                write_log -f "${logfile}" "00000000 update_lastrun_and_nextrun on plugin:"\
			"[${plugin_name}] for [empty, add new nextrun item as ${nextrun}]"\
			"success";
	fi
  else
	### only collect stderr output
	### sed command c to replace the whole line.
        errinfo=$( sed -i '/^'${plugin_name}'\>/c'"${plugin_name}"' '"${nextrun}"'' ${TMP_NEXTRUN} 2>&1 1>/dev/null )
	rc=$?
	if [ "${rc}" != "0" ]; then
                write_log -f "${logfile}" "CRIT0000 update_lastrun_and_nextrun on plugin:"\
			"[${plugin_name}] for [update nextrun as ${nextrun}]"\
			"error: [${errinfo}]";
	else
                write_log -f "${logfile}" "00000000 update_lastrun_and_nextrun on plugin:"\
			"[${plugin_name}] for [update nextrun as ${nextrun}]"\
			"success";
        fi
  fi
  return ${rc}
}


# Update status of plugin result.
# Note:         only called on plugin finished or output result.
#
update_status() {
  local plugin_name=${1} rc= errinfo= ; shift
  local content=$*
  local now=$(date +%s)
  local headline="NOTICE  --*--< DO NOT EDIT THIS FILE >--*-- \n\n"
  
  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 update_status error: missing plugin name";
        return 1
  }

  if [ -z "$( echo "${plugin_name}" | grep -E -o "^eminfo_" )" ]; then
	local logfile="${EMINFO_LOG}"
  else
	local logfile="${INNER_LOG}"                                                                                   
  fi

  
  touch ${TMP_STATUS}
  [ ! -s ${TMP_STATUS} ] && echo -e "${headline}" > ${TMP_STATUS}

  local l_record=$(awk '/^'${plugin_name}'\>/' ${TMP_STATUS} 2>&-)
  if [ -z "${l_record}" ]; then
	echo "${plugin_name} ${now} ${content}" >> ${TMP_STATUS} 2>/dev/null
	rc=$?
	if [ "${rc}" != "0" ]; then
	       write_log -f "${logfile}" "E0000000 update_status on plugin:"\
			"[${plugin_name}] for [append newitem] error";
	else
	       write_log -f "${logfile}" "00000000 update_status on plugin:"\
			"[${plugin_name}] for [append newitem] success";
	fi
  else
	### following sed command can NOT deal with special chars. (if ${content} contains /)
	# sed -i '/^'${plugin_name}'\>/s/.*/'${plugin_name}' '${now}' '${content}'/' ${TMP_STATUS}
	errinfo=$( sed -i '/^'"${plugin_name}"'\>/d' ${TMP_STATUS} 2>&1 1>/dev/null )
	rc=$?
	if [ "${rc}" != "0" ]; then
	       write_log -f "${logfile}" "E0000000 update_status on plugin:"\
			"[${plugin_name}] for [delete olditem error: ${errinfo}]";
	else
	       write_log -f "${logfile}" "00000000 update_status on plugin:"\
			"[${plugin_name}] for [delete olditem] success"
	       echo "${plugin_name} ${now} ${content}" >> ${TMP_STATUS} 2>/dev/null
	       rc=$?
	       if [ "${rc}" != "0" ]; then
			write_log -f "${logfile}" "E0000000 update_status on plugin:"\
				"[${plugin_name}] for [append newitem] error";
	       else
			write_log -f "${logfile}" "00000000 update_status on plugin:"\
				"[${plugin_name}] for [append newitem] success";
	       fi
	fi
  fi
  return ${rc}
}


# Check accumulated return-err number overthan err-limit or not
# Output:	{0 =>no | 1 =>yes}  {now_err_num}  {err_num_limit}  
# Usage:        check_repeat_errcount  plugin_name
# Example:	check_repeat_errcount  check_sysload
#
check_repeat_errcount() {
  local plugin_name=$1 result=
  local headline="NOTICE  --*--< DO NOT EDIT THIS FILE >--*-- \n\n"
  
  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 check_repeat_errcount error: missing plugin name";
        return 1
  }

  touch ${TMP_REPEAT}
  [ ! -s ${TMP_REPEAT} ] && echo -e "${headline}" > ${TMP_REPEAT}

  local _repeat_errlimit=$( get_maxerr_times "${plugin_name}" )
  local repeat_errcount=$(awk '/^'${plugin_name}'\>/ {print $2;exit}' ${TMP_REPEAT} 2>&-)
  [ -z "${repeat_errcount}" -o ! -z "${repeat_errcount//[0-9]}" ] && repeat_errcount=0  # set default whatever.

  [ "$(echo "${repeat_errcount}>=${_repeat_errlimit}" | bc 2>&-)" == "1" ] && {
	result=1    # reached  
  } || {
	result=0    # unreached
  }

  echo "${result}" "${repeat_errcount}" "${_repeat_errlimit}"
}

# Accumulated return-err number +1 
# Note: 	only called at plugin return err (non-zero)
# Usage:        add_repeat_errcount  plugin_name
# Example:	add_repeat_errcount  check_sysload
# Note:   null 	        =>   insert new and update to 1
# 	  not numberic  =>   update to 1
#         numberic	=>   update to +1
#
add_repeat_errcount() {
  local plugin_name=$1  rc=  errinfo=
  local headline="NOTICE  --*--< DO NOT EDIT THIS FILE >--*-- \n\n"

  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 add_repeat_errcount error: missing plugin name";
        return 1
  }

  touch ${TMP_REPEAT}
  [ ! -s ${TMP_REPEAT} ] && echo -e "${headline}" > ${TMP_REPEAT}

  local repeat_errcount=$(awk '/^'${plugin_name}'\>/ {print $2;exit}' ${TMP_REPEAT} 2>&-)
  if [ -z "${repeat_errcount}" ]; then		## null => update to 1 (add to last line)
        ### only collect stderr output
	errinfo=$( sed -i '$s/$/\n'"${plugin_name}"' 1/' ${TMP_REPEAT} 2>&1 1>/dev/null )
   	rc=$?
	if [ "${rc}" != "0" ]; then
		write_log -f "${EMINFO_LOG}" "E0000000 add_repeat_errcount on plugin:"\
			"[${plugin_name}] for [empty, add new item as 1]"\
			"error: [${errinfo}]";
	else
		write_log -f "${EMINFO_LOG}" "00000000 add_repeat_errcount on plugin:"\
			"[${plugin_name}] for [empty, add new item as 1]"\
			"success";
	fi
  else
	if [ ! -z "${repeat_errcount//[0-9]}" ]; then    ## not null but invalid => update to 1
		### only collect stderr output
		errinfo=$( sed -i '/^'"${plugin_name}"'\>/c'"${plugin_name}"' 1' ${TMP_REPEAT} 2>&1 1>/dev/null )
		rc=$?
		if [ "${rc}" != "0" ]; then
			write_log -f "${EMINFO_LOG}" "E0000000 add_repeat_errcount on plugin:"\
				"[${plugin_name}] for [invalid => not numberic [${repeat_errcount}] and update as 1]"\
				"error: [${errinfo}]";
		else
			write_log -f "${EMINFO_LOG}" "00000000 add_repeat_errcount on plugin:"\
				"[${plugin_name}] for [invalid => not numberic [${repeat_errcount}] and update as 1]"\
				"success";
		fi
	else
  		local num=$(( ${repeat_errcount} + 1 ))  ## not null and numberic => update to +1
		### only collect stderr output
		errinfo=$( sed -i '/^'"${plugin_name}"'\>/c'"${plugin_name}"' '"${num}"'' ${TMP_REPEAT} 2>&1 1>/dev/null )
		rc=$?
		if [ "${rc}" != "0" ]; then
			write_log -f "${EMINFO_LOG}" "E0000000 add_repeat_errcount on plugin:"\
				"[${plugin_name}] for [valid => [${repeat_errcount}] and update as +1]"\
				"error: [${errinfo}]";
		else
			write_log -f "${EMINFO_LOG}" "00000000 add_repeat_errcount on plugin:"\
				"[${plugin_name}] for [valid => [${repeat_errcount}] and update as +1]"\
				"success";
		fi
	fi
  fi
  return ${rc}
}

# Reset accumulated return-err number to 0
# Note:		only called at plugin return ok (zero)
# Example:	zero_repeat_errcount  check_sysload
#
zero_repeat_errcount() {
  local plugin_name=$1  rc=  errinfo=
  local headline="NOTICE  --*--< DO NOT EDIT THIS FILE >--*-- \n\n"

  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 zero_repeat_errcount error: missing plugin name";
        return 1
  }

  touch ${TMP_REPEAT}
  [ ! -s ${TMP_REPEAT} ] && echo -e "${headline}" > ${TMP_REPEAT}

  # only collect stderr  output
  errinfo=$( sed -i '/^'"${plugin_name}"'\>/d' ${TMP_REPEAT} 2>&1 1>/dev/null)
  rc=$?
  if [ "${rc}" == "0" ]; then
	write_log -f "${EMINFO_LOG}" "00000000 zero_repeat_errcount on plugin:"\
		"[${plugin_name}] success.";
  else
	write_log -f "${EMINFO_LOG}" "E0000000 zero_repeat_errcount on plugin:"\
		"[${plugin_name}] error: [${errinfo}]";
  fi

  return "${rc}"
}

# List enabled plugins include inners
#
list_enabled_plugin_section() {
  # list_plugin_section | while read plugin_name
  for plugin_name in `list_plugin_section`
  do
	[ "$(get_enable ${plugin_name})" == "yes" ] && echo "${plugin_name}"
  done

  for plugin_name in `list_inner_plugin_section`
  do
	echo "${plugin_name}"
  done
}

# List running plugins include inners
# 
list_running_plugin_section() {
  for plugin_name in `list_plugin_section` `list_inner_plugin_section`
  do
	lock_result=$(check_lock ${plugin_name})
	[ ! -z "${lock_result}" -a -z "${lock_result//[0-9]}" ] && echo "${plugin_name}"
  done
}

# Generate an empty temporary file for plugin if needed.
# Output:	path of temporary file
# Usage:	gen_tmpfile  plugin_name
# Example:	gen_tmpfile  check_sysload
#
gen_tmpfile() {
  local plugin_name=$1  rc=  errinfo=
  [ -z "${plugin_name}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 gen_tmpfile error: missing plugin name";
	return 1
  }

  [ ! -d "${TMP_DIR}/${plugin_name}" ] && /bin/mkdir -p ${TMP_DIR}/${plugin_name} 2>&-
  local filepath="${TMP_DIR}/${plugin_name}/${plugin_name}_$(/bin/mktemp -u XXXXXXXX 2>&-)"
  # only collect stderr output.
  errinfo=$( touch "${filepath}" 2>&1 1>/dev/null )
  rc=$?
  if [ "${rc}" == "0" ]; then
  	echo "${filepath}"
	write_log -f "${EMINFO_LOG}" "00000000 gen_tmpfile success:"\
		"[${filepath}]";
  else
	write_log -f "${EMINFO_LOG}" "E0000000 gen_tmpfile error:"\
		"touch tmpfile [${filepath}]"\
		"return error: [${errinfo}]";
  fi

  return "${rc}"
}

# Time to run plugin or not ( nower timestamp > next-run timestamp or not)
# Usage:	time2run_ornot  plugin_name
# Output:	yes | no
#
time2run_ornot() {
  local plugin_name=$1 result=
  [ -z "${plugin_name}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 time2run_ornot error: missing plugin name";
	return 1
  }
  local nextrun=$(get_nextrun ${plugin_name})
  local now=$(date +%s)
  [ "$(echo "${nextrun} <= ${now}"|bc)" == "1"  ] && result="yes" || result="no"
  echo "${result}"
}

# Generate run-lock on plugin  (atomic operation)
# Usage:        gen_lock  plugin_name
#
gen_lock() {
  local plugin_name=$1  rc=  errinfo=  logfile=  p_path=
  [ -z "${plugin_name}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 gen_lock error: missing plugin name";
  	return 1
  }
  [ -z "$( echo "${plugin_name}" | grep -E -o "^eminfo_" )" ] && {
	p_path="${PLUGIN_DIR}/${plugin_name}"
	logfile="${EMINFO_LOG}"
  } || {
   	p_path="${INNER_DIR}/${plugin_name}"
	logfile="${INNER_LOG}"
  }
  # only collect stderr output.
  errinfo=$( ln -s "${p_path}" "${RUN_DIR}/${plugin_name}.lock" 2>&1 1>/dev/null )
  rc=$?
  if [ "${rc}" != "0" ]; then
	write_log -f "${logfile}" "E0000000 gen_lock on plugin:"\
		"[${plugin_name}] error: [${errinfo}]";
  else
	write_log -f "${logfile}" "00000000 gen_lock on plugin:"\
		"[${plugin_name}] success.";
  fi

  return "${rc}"
}

# Unlock plugin
# Usage:        un_lock  plugin_name
#
un_lock() {
  local plugin_name=$1  rc=  errinfo=  logfile=
  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 un_lock error: missing plugin name";
        return 1
  }
  [ -z "$( echo "${plugin_name}" | grep -E -o "^eminfo_" )" ] && {
        logfile="${EMINFO_LOG}"
  } || {
        logfile="${INNER_LOG}"
  }
  # only collect stderr output.
  errinfo=$( unlink "${RUN_DIR}/${plugin_name}.lock" 2>&1 1>/dev/null )
  rc=$?
  if [ "${rc}" != "0" ]; then
	write_log -f "${logfile}" "E0000000 un_lock on plugin:"\
		"[${plugin_name}] error: [${errinfo}]";
  else
	write_log -f "${logfile}" "00000000 un_lock on plugin:"\
		"[${plugin_name}] success";
  fi
  return "${rc}"
}

# Remove pidfile for plugin
# Usage:	del_fpid  plugin_name
#
del_fpid() {
  local plugin_name=$1  rc=  errinfo=  logfile=
  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 del_fpid error: missing plugin name";
        return 1
  }
  [ -z "$( echo "${plugin_name}" | grep -E -o "^eminfo_" )" ] && {
        logfile="${EMINFO_LOG}"
  } || {
        logfile="${INNER_LOG}"
  }
  # only collect stderr output.
  errinfo=$( rm -f "${RUN_DIR}/${plugin_name}.pid" 2>&1 1>/dev/null )
  rc=$?
  if [ "${rc}" != "0" ]; then
	write_log -f "${logfile}" "E0000000 del_fpid on plugin:"\
		"[${plugin_name}] error: [${errinfo}]";
  else
	write_log -f "${logfile}" "00000000 del_fpid on plugin:"\
		"[${plugin_name}] success.";
  fi
  return "${rc}"
}

# Check run-lock status for plugin
# Output:	nolock | linkerror | start timestamp (plugin is running)
# Usage:        check_lock  plugin_name
# Example:	check_lock  check_sysload
#
check_lock() {
  local plugin_name=$1 result=
  [ -z "${plugin_name}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 check_lock error: missing plugin name";
	return 1
  }
  # [ -e ${RUN_DIR}/${plugin_name}.lock ] && {   ###  never check broken link: never return linkerror
  if [ -L "${RUN_DIR}/${plugin_name}.lock" ]; then
	local f=$(readlink "${RUN_DIR}/${plugin_name}.lock" 2>&-)
	[ -z "$( echo "${plugin_name}" | grep -E -o "^eminfo_" )" ] && {
        	local p_path="${PLUGIN_DIR}/${plugin_name}"
		local logfile="${EMINFO_LOG}"
	} || {
		local p_path="${INNER_DIR}/${plugin_name}"
		local logfile="${INNER_LOG}"
	}
	if [ "${f}" == "${p_path}" -a -f "${p_path}" ]; then
		result=$(stat -c %Y ${RUN_DIR}/${plugin_name}.lock 2>&-) 
		[ -z "${result}" -o ! -z "${result//[0-9]}" ] && {
			write_log -f "${logfile}" "E0000000 check_lock on [${plugin_name}] error: "\
				"runlock timestamp is not numberic: [${result}], "\
				"return linkerror";
			result="linkerror"
		}
	else
		write_log -f "${logfile}" "E0000000 check_lock on [${plugin_name}] error: "\
				"runlock link->target is mistake or target not exist: "\
				"[${f}] ==> [${p_path}], "\
				"return linkerror";
		result="linkerror"
	fi
  else
	result="nolock"
  fi

  echo "${result}"
}

# Remove error lock and dead pid for plugin
# Clear conditions:
# 1. lock exists, but run-lock link error   ==>  remove lock
# 2. lock exists, but pid file not exists   ==>  remove lock
# 3. lock exists, pid file exist, but according to the pid file, no process running ==> remove lock,remove pidfile
# 4. pid file exists, but according to the pid file, no process running ==> remove pidfile
# Note:		No arguments will clear all plugins.
# Usage:	clear_dead_lock_pid  [ plugin_name ]
# Example1:	clear_dead_lock_pid  check_sysload
# Example2:	clear_dead_lock_pid
# LogFlag:	D0000000
#
clear_dead_lock_pid() {
  local plugin_name=$1

  clear_single_dead_lock_pid() {
	local _p=$1  _rc=
	[ -z "${_p}" ] && {
		write_log -f "${EMINFO_LOG}" "E0000000 clear_single_dead_lock_pid error: missing plugin name";
		return 1
	}
  	if [ -z "$( echo "${_p}" | grep -E -o "^eminfo_" )" ]; then
        	local logfile="${EMINFO_LOG}"
	else
        	local logfile="${INNER_LOG}"
  	fi

	[ -L "${RUN_DIR}/${_p}.lock" ] && {
		if [ "$(check_lock  "${_p}")" == "linkerror" ]; then   ### condition: 1
			write_log -f ${logfile} "D0000000 EMINFO remove linkerror lock for"\
				"[${_p}]: link error";
			un_lock "${_p}"
		fi
		if [ ! -f "${RUN_DIR}/${_p}.pid" ]; then  ### condition: 2
			write_log -f ${logfile} "D0000000 EMINFO remove dead lock for"\
				"[${_p}]: pid not exists";
			un_lock "${_p}"        
		else
			check_ps_by_pid_file "${RUN_DIR}/${_p}.pid" 1>/dev/null 2>&1
			_rc=$?
			if [ "$_rc" != "0" ]; then  ### condition: 3
				write_log -f ${logfile} "D0000000 EMINFO remove dead lock and pid for"\
					"[${_p}]: pid exists but process not running";
				un_lock "${_p}"  	# unlock first
				del_fpid "${_p}"	# then del pid file
			fi
		fi
	}
	if [ -s "${RUN_DIR}/${_p}.pid" ]; then
		check_ps_by_pid_file "${RUN_DIR}/${_p}.pid" 1>/dev/null 2>&1
		_rc=$?
		if [ "$_rc" != "0" ]; then  ### condition: 4
			write_log -f ${logfile} "D0000000 EMINFO remove dead pid for [${_p}]";
			del_fpid "${_p}"
		fi
	fi
  }

  if [ -z "${plugin_name}" ]; then
	# list_plugin_section | while read p   
	for p in `list_plugin_section`
	do
		clear_single_dead_lock_pid "${p}"
	done 
	for q in `list_inner_plugin_section`
	do
		clear_single_dead_lock_pid "${q}"
	done
  else
	clear_single_dead_lock_pid "${plugin_name}"
  fi
}

# According to input pid file to stop process.
# Steps:
# 1. read first line from pid file as pids.
#  1.1. for each pid, if directory /proc/${pid}/ exists, search all of its son-pids
#  1.2. send signal TERM to all son pids
#  1.3. read /proc/${pid}/cmdline as variable cmdline1
#  1.4. send signal TERM to ${pid}, sleep 3 seconds in case the process trap signal TERM
#  1.5. if directory /proc/${pid}/ still exists, read /proc/${pid}/cmdline as variable cmdline2
#  1.6. if cmdline1=cmdline2, send signal KILL to ${pid}, no more than 3 times.
# 2. remove pid file
# Usage:	stopps_by_pidfile   /path/to/pid/file
# Example:	stopps_by_pidfile   /var/run/crond.pid
# LogFlag: 	STP00000
#
stopps_by_pidfile() {
  local fpid=$1
  [ -z "${fpid}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 stopps_by_pidfile error:"\
		"missing arguments, fpid=[${fpid}]";
  	return 1
  }

  if [ -f "${fpid}" ]; then
	read line < ${fpid}    ### step: 1
	write_log -f "${EMINFO_LOG}" "STP00000 EMINFO read pids from pidfile:"\
		"[${fpid}] result: [${line}]";

	for x in `echo ${line}`;do
		[ -z "${x//[0-9]/}" -a -d "/proc/${x}" ] && {
			local kidpids=$(get_pidkids_bypid ${x})    ### step: 1.1
			write_log -f "${EMINFO_LOG}" "STP00000 EMINFO get_kidpids for pid:"\
				"[${x}] result:[${kidpids}]";

			for cpid in `echo ${kidpids}`    ### step: 1.2
			do
				local cmdline=$(ps -p "${cpid}" -o cmd= 2>&-)
				write_log -f "${EMINFO_LOG}" "STP00000 EMINFO terminating child pid:"\
					"[${cpid}] => [${cmdline}] SIG:TERM";
				kill -15  "${cpid}" 1>&- 2>&-
			done

			local cmdline1=$(cat /proc/${x}/cmdline 2>&-)    ### step: 1.3

			local cmdline=$(ps -p "${x}" -o cmd= 2>&-)
			write_log -f "${EMINFO_LOG}" "STP00000 EMINFO terminating father pid:"\
				"[${x}] => [${cmdline}] SIG:TERM ";
			kill -15 "${x}" 1>&- 2>&-	 ### step: 1.4
			sleep 3   ### in case the process trap signal TERM

			if [ -d "/proc/${x}" ]; then
				local cmdline2=$(cat /proc/${x}/cmdline 2>&-)    ### step: 1.5
				local kn=1  kmax=3
				until [ "${cmdline1}" != "${cmdline2}" ]     ### step: 1.6
				do
					write_log -f "${EMINFO_LOG}" "STP00000 EMINFO father pid:"\
						"[${x}] => [${cmdline2}] still running, kill it by SIG:KILL, times:[${kn}]";
					kill -9 ${x} 1>&- 2>&-
					sleep 0.1
					local cmdline2=$(cat /proc/${x}/cmdline 2>&-)
					((kn++))
					### kill the process no more than ${kmax} times.
					[ "$( echo "${kn}>${kmax}" | bc 2>&- )" == "1" ] && break
				done
			else
				write_log -f "${EMINFO_LOG}" "STP00000 EMINFO terminate father pid:"\
					"[${x}] => [${cmdline}] SIG:TERM success";
			fi
		}
	done

	local errinfo=  rc=
  	errinfo=$( rm -f "${fpid}" 2>&1 1>/dev/null )    ### step: 2
	rc=$?
	if [ "${rc}" != "0" ]; then
		write_log -f "${EMINFO_LOG}" "STP00000 EMINFO remove pidfile:"\
			"[${fpid}] error: [${errinfo}]";
		return 2
	else
		write_log -f "${EMINFO_LOG}" "STP00000 EMINFO remove pidfile:"\
			"[${fpid}] success";
		return 0
	fi
  else
	write_log -f "${EMINFO_LOG}" "E0000000 stopps_by_pidfile error:"\
		"input pidfile not exists: [${fpid}]";
	return 3
  fi
}

# Stop plugin	( kill process / remove pid / unlock )
# Usage:	stop_single_plugin   plugin_name
# LogFlag: 	STP00000 
#
stop_single_plugin() {
  local plugin_name=$1  
  local pidfile="${RUN_DIR}/${plugin_name}.pid"
  if [ -z "${plugin_name}" ]; then
	write_log -f "${EMINFO_LOG}" "E0000000 stop_single_plugin error: missing plugin name";
	return 1
  else
	write_log -f "${EMINFO_LOG}" "STP00000 EMINFO stop plugin"\
		"[${plugin_name}]: 1 => stop process on pidfile: [${pidfile}]";
  	stopps_by_pidfile "${pidfile}"
	write_log -f "${EMINFO_LOG}" "STP00000 EMINFO stop plugin"\
		"[${plugin_name}]: 2 => remove lockfile";
  	un_lock "${plugin_name}"
  fi
}

# Check plugin has been running timeout or not  (must be running,otherwise return error directly)
# Output:	yes | no | error (maybe not ruuning)
# Usage:	timeout_ornot  plugin_name
# Example:	timeout_ornot  check_sysload
#
timeout_ornot() {
  local plugin_name=$1 result=
  [ -z "${plugin_name}" ] && {
	write_log -f "${EMINFO_LOG}" "E0000000 timeout_ornot error: missing plugin name";
	return 1
  }
  local exec_tmout=$(conv_time2sec "$(get_exec_tmout ${plugin_name})")
  local starttime=$(check_lock ${plugin_name})
  if [ -z "${starttime}" -o ! -z "${starttime//[0-9]/}" ]; then
	write_log -f "${EMINFO_LOG}" "E0000000 timeout_ornot error:"\
		"starttime [${starttime}] not numberic on plugin "\
		"[${plugin_name}]: maybe not running.";
	result="error"
  else
	local durationtime=$(echo " "$(date +%s)" - "${starttime}" " | bc 2>&-) 
  	[ "$(echo "${durationtime} >= ${exec_tmout}"|bc)" == "1" ] && result="yes" || result="no"
  fi
  echo "${result}"
}

# Add run-lock on plugin while pid file not exist
# Note:		called to add run-lock at next scan period begins, previous plugin has already finished. 
# 		No need to check previous plugin running timeout or not
# Output:	0 1   ==>  Succ | Fail
# Usage:        add_runlock_on_pid_notexist      plugin_name
# LogFlag: 	P0000000
#
add_runlock_on_pid_notexist(){
  local plugin_name=$1 _rc=
  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 add_runlock_on_pid_notexist error: missing plugin name";
        return 1
  }
  [ -z "$( echo "${plugin_name}" | grep -E -o "^eminfo_" )" ] && {
        local logfile="${EMINFO_LOG}"
  } || {
        local logfile="${INNER_LOG}"
  }

  gen_lock "${plugin_name}"
  _rc=$?
  if [ "${_rc}" != "0" ]; then
	write_log -f ${logfile} "P0000000 EMINFO add runlock on"\
		"[${plugin_name}]: without pidfile but add runlock: failed. EXIT";
	return 1
  else
	write_log -f ${logfile} "P0000000 EMINFO add runlock on"\
		"[${plugin_name}]: without pidfile and add runlock: succeed. OK";
	return 0
  fi
}

# Check run-lock on plugin while pid file exists
# Note:		called to check run-lock at next scan period begins, previous plugin is still running.
# Output: 	0 1 2 3 4 5
# Steps:
#   0: running, but timeout  ==>  stop plugin  ==>  process_plugin_timeout  ==>  skip 
#   1: running, and NOT timeout  ==>  skip
#   2: linkerror  ==>  remove dead run-lock  ==>  skip
#   3: nolock  ==>  add run-lock  ==>  failed  ==>  skip
#   4: nolock  ==>  add run-lock  ==>  succ    ==>  process_plugin
#   5: unknown  ==>  skip
# Usage:	check_runlock_on_pid_exist  plugin_name
# Example:	check_runlock_on_pid_exist  check_sysload   
# LogFlag: 	L0000000
#
check_runlock_on_pid_exist() {
  local plugin_name=$1  r_c=
  [ -z "${plugin_name}" ] && {
        write_log -f "${EMINFO_LOG}" "E0000000 check_runlock_on_pid_exist error: missing plugin name";
        return 1
  }

  [ -z "$( echo "${plugin_name}" | grep -E -o "^eminfo_" )" ] && {
	local logfile="${EMINFO_LOG}"
  } || {
	local logfile="${INNER_LOG}"
  }

  local lockinfo=$(check_lock "${plugin_name}")
  [ -z "${lockinfo//[0-9]/}" ] && {	    ###   is running
	#### this will lead to plenty of records in {EMINFO_LOG}  while plugin running for a long time.
	## write_log -f ${logfile} L0000000 EMINFO plugin "[${plugin_name}]" already running. CHECK EXEC_TMOUT
	if [ "$(timeout_ornot "${plugin_name}")" == "yes" ]; then   ### condition: 0
		write_log -f ${logfile} "L0000000 EMINFO plugin"\
			"[${plugin_name}] running but timeout. STOP IT";
		process_plugin_timeout "${plugin_name}"
		return 0
	else    
		#### this will lead to plenty of records in {EMINFO_LOG}  while plugin running for a long time.
		## write_log -f ${logfile} L0000000 EMINFO plugin "[${plugin_name}]" running and not_timeout. SKIP
		return 1	### condition: 1
	fi
  }

  [ "${lockinfo}" == "linkerror" ] && {
	un_lock "${plugin_name}"
	write_log -f ${logfile} "L0000000 EMINFO plugin"\
		"[${plugin_name}] running but linkerror. UNLOCK IT";
	return 2      ### condition: 2
  }

  [ "${lockinfo}" == "nolock" ] && {    ### not running
	gen_lock "${plugin_name}"
        r_c=$?
	if [ "${r_c}" != "0" ]; then
		write_log -f ${logfile} "L0000000 EMINFO add runlock on"\
			"[${plugin_name}]: without runlock but add runlock failed. EXIT";
		return 3      ### condition: 3
	else		
		write_log -f ${logfile} "L0000000 EMINFO add runlock on"\
			"[${plugin_name}]: without runlock and add runlock succeed. OK";
		return 4      ### condition: 4
	fi
  }

  write_log -f ${logfile} "L0000000 EMINFO plugin"\
	"[${plugin_name}] something unknown occure. EXIT";
  return 5 	### condition: 5
}

# List plugin status and scheduling information
#   		include: enable status starttime durationtime lastruntime frequency nextruntime repeaterrnum
# Usage:	list_plugin_status  [ plugin_name1 plugin_name2 plugin_name3 ... ]    
# Example1:	list_plugin_status  check_sysload  check_cpu_usage
# Example2:	list_plugin_status  all
#
list_plugin_status() {
  local plugin_name="$*"
  local headline="Plugin Enable Running StartOn Duration LastRun Frequency NextRun RepeatErr"
  list_single_status() {
	local _p=$1 enable= running= starttime= durationtime= lastruntime= frequency= nextruntime= repeaterrnum=
	local lastruntime=$(get_lastrun $_p) 
    	local frequency=$(get_frequency $_p)
	local nextruntime=$(get_nextrun $_p)
	local repeaterrnum=$(awk '/^'${_p}'\>/ {print $2;exit}' ${TMP_REPEAT} 2>&-) 
	[ -z "${repeaterrnum}" -o ! -z "${repeaterrnum//[0-9]}" ] && repeaterrnum=0

	[ ! -z "$( echo "${_p}" | grep -E -o "^eminfo_" )" ] && {
		enable="yes"
	} || {
		enable=$(get_enable "${_p}")
        }

	if [ -z "${lastruntime//[0-9]/}" ]; then
		lastruntime=$(date -d "1970-01-01 UTC ${lastruntime} seconds" +%F_%T)
	else
		[ "${lastruntime}" == "never_run" ] && {
			lastruntime="Never_Run"
		} || {
			[ "${lastruntime}" == "invalid_lastrun" ] && {
				lastruntime="Internal_Error"
			} || {
				lastruntime="Unknown"
			}
		}
	fi

	if [ -z "${nextruntime//[0-9]/}" ]; then
		nextruntime=$(date -d "1970-01-01 UTC ${nextruntime} seconds" +%F_%T)
	else
		[ "${nextruntime}" == "null" ] && {
			nextruntime="NULL"
		} || {
			[ "${nextruntime}" == "invalid_nextrun" ] && {
				nextruntime="Internal_Error"
			} || {
				nextruntime="Unknown"
			}
		}
	fi

 	[ "${enable}" == "yes" ] && {
		enable="Yes"
	} || {
		enable="No" 
		nextruntime="-"
	}

	local lockinfo=$(check_lock $_p)
 	if [ -z "${lockinfo//[0-9]/}" ]; then
		running="Yes"
		starttime=$(date -d "1970-01-01 UTC ${lockinfo} seconds" +%F_%T)
		durationtime="$( echo "$(date +%s) - ${lockinfo}" | bc 2>&- )s"
	else
		running="No"
		starttime="-"
		durationtime="-"
	fi

	echo "$_p ${enable} ${running} ${starttime} ${durationtime} ${lastruntime} ${frequency} ${nextruntime} ${repeaterrnum}"
	# echo "p=$_p e=${enable} r=${running} s=${starttime} d=${durationtime} l=${lastruntime} f=${frequency} n=${nextruntime} r=${repeaterrnum}"
	
	
  }

  if [ "${plugin_name}" == "all" ]; then
		{  echo "${headline}"
		for p in `list_plugin_section`
		do
			[ ! -z "${p}" ] &&  list_single_status "${p}"
		done 
		#for q in `list_inner_plugin_section`
		#do
			#[ ! -z "${q}" ] && list_single_status "${q}"
		#done
		} | column -t 
  else
		{ echo "${headline}" 
		for o in `echo "${plugin_name}"`
		do
			list_single_status "${o}" 
		done
		} | column -t
  fi
}

# Enable Plugin (update config file to set enable = yes)
# LogFlag	ENAB0000
#
enable_plugin(){
  local plugin_name=$1  rc=
  write_log -f "${EMINFO_LOG}" "ENAB0000 enable_plugin trying to enable plugin [${plugin_name}]";
  update_eminfo_config "${plugin_name}" "enable" "yes"
  rc=$?
  return "${rc}"
}

# Disable Plugin (update config file to set enable = no)
# LogFlag	DSAB0000
#
disable_plugin() {
  local plugin_name=$1  rc=
  write_log -f "${EMINFO_LOG}" "DSAB0000 disable_plugin trying to disable plugin [${plugin_name}]";
  update_eminfo_config "${plugin_name}" "enable" "no"
  rc=$?
  return "${rc}"
}

# Reset scheduling information and repeat err-num of plugin
# Note:		No arguments will reset all plugins
# Usage:	init_plugin  [plugin_name]
# Example1:	init_plugin  check_sysload
# Example2:	init_plugin 
# LogFlag:	INIT0000
# 
init_plugin() {
  local plugin_name=$1
  if [ -z "${plugin_name}" ]; then
	write_log -f "${EMINFO_LOG}" "INIT0000 resetting all plugins ...";
	: > ${TMP_LASTRUN} >/dev/null 2>&1
  	: > ${TMP_NEXTRUN} >/dev/null 2>&1
  	: > ${TMP_REPEAT}  >/dev/null 2>&1
  else
	write_log -f "${EMINFO_LOG}" "INIT0000 resetting plugin: [${plugin_name}] ..."
 	sed -i '/^'"${plugin_name}"'\>/d' ${TMP_LASTRUN} > /dev/null 2>&1
 	sed -i '/^'"${plugin_name}"'\>/d' ${TMP_NEXTRUN} > /dev/null 2>&1
 	sed -i '/^'"${plugin_name}"'\>/d' ${TMP_REPEAT}  > /dev/null 2>&1
  fi
  return $?
}

# List base-config-name ==> config-value of plugin
# Note:		No arguments will list all plugins
# Note:		Extra (user-defination) config-name will not be displayed.
# Usage:  view_base_config 	plugin_name
# 
view_base_config() {
  local plugin_name=$1
  [ -z "${plugin_name}" ] && {
	echo_red "view_base_config error: please specify plugin name."; echo
	return 1
  }
  echo_green "[${plugin_name}]: basic configuration" ; echo
  { 
	echo "config_name ==> value ==> is_default"
  	for cname in ${ARRAY_BASE_CONFIG[@]} 
  	do
        	cvalue=$(read_eminfo_config ${plugin_name} ${cname})
        	if [ -z "${cvalue}" ]; then
                	cvalue="$(read_eminfo_config default ${cname}) ==> Yes"
		else
			cvalue="${cvalue} ==> No"
        	fi
        	echo -e  "${cname} ==> ${cvalue} "
  	done
  } | column -t -s "==>"
}

# List user-defined-config-name ==> config-value of plugin
# Note:         No arguments will list all plugins
# Note:         Basic config-name will not be displayed.
# Usage:  view_extra_config      plugin_name
# 
view_extra_config() {
  local plugin_name=$1  silient=$2
  [ -z "${silient}"  ] && silient=0 || silient=1
  [ "${silient}" == "0" -a -z "${plugin_name}" ] && {
	echo_red "view_extra_config error: please specify plugin_name."; echo
 	return 1
  }
  [ "${silient}" == "0" ] && { 
	echo_green "[${plugin_name}]: extra configuration"
	echo
  }
  {
	local search_tag=0  headline="config_name(user-def) ==> value"
  	for cname in `list_section_keys "${plugin_name}"`
  	do
		[ "$(echo -e "${ARRAY_BASE_CONFIG[@]}"  | grep -E -o -w "${cname}")" == "" ] && {  ### 2. user-def config
			cvalue=$(read_eminfo_config ${plugin_name} ${cname})
			[ "${silient}" == "0" -a "${search_tag}" == "0" ] && echo -e "${headline}"
			echo -e "${cname} ==> ${cvalue}"
			search_tag=1
		}
  	done
  } | column -t -s "==>"
}

# Process plugin 
# Note:		core function, each enabled plugin will be handed over to this function.
# Usage:        process_plugin   plugin_name
# LogFlag:	random 8 character
#
process_plugin() {

  local plugin_name=$1

  # Step 1: set jid / set debug flag / set logfile
  local jid=$(/bin/mktemp -u XXXXXXXX 2>&-)      ### set random/unique jid
  export _LOG="${EMINFO_LOG}"          ### set logfile 
  local debug=$(get_debug "${plugin_name}")   ### set debug flag
  [ "${debug}" == "yes" ] && export _DEBUG="1" || export _DEBUG="0"

  # Step 2.1: check current overloaded or not,  yes ==> process_sysoverload ==> return
  SYSLOAD_UPLIMIT=$( read_eminfo_config global sysload_uplimit )
  [ -z "${SYSLOAD_UPLIMIT}" -o ! -z "${SYSLOAD_UPLIMIT//[0-9]}" ] && SYSLOAD_UPLIMIT=30
  local sysload=$( cut -d" " -f1 /proc/loadavg 2>&- )
  if [ "$(echo  "${sysload} > $SYSLOAD_UPLIMIT" | bc 2>&-)" == "1" ]; then	### plugin finished.
	write_log "${jid} ${plugin_name} system overloaded,"\
		"[${sysload}] > [${SYSLOAD_UPLIMIT}], EXIT";
	process_sysoverload "${plugin_name}" "${sysload}" "${SYSLOAD_UPLIMIT}"
	# update_lastrun_and_nextrun "${plugin_name}"		## no need, processed in process_sysoverload()
	un_lock "${plugin_name}"	# unlock first
	del_fpid "${plugin_name}"	# then del pid file
	write_log ${jid} ${plugin_name}\
		"update lastrun time / release LOG / release runlock done. FINISHED.";
	unset _LOG
	return 1
  else
	write_log ${jid} ${plugin_name} "system load normal: [${sysload}] CONTINUE";
  fi

  # Step 2.2: check current eminfo kids exceed or not,  yes ==> process_kidsexceed ==> return
  KIDSNUM_UPLIMIT=$( read_eminfo_config global max_kidsnum )
  [ -z "${KIDSNUM_UPLIMIT}" -o ! -z "${KIDSNUM_UPLIMIT//[0-9]}" ] && KIDSNUM_UPLIMIT=30
  if [ -f "${PID_FILE}" -a -s "${PID_FILE}" ]; then
 	read empid < "${PID_FILE}"
  	local kidsnum=$( get_kidsnum "${empid}" )
  	if [ "$(echo  "${kidsnum} > $KIDSNUM_UPLIMIT" | bc 2>&-)" == "1" ]; then	### plugin finished.
		write_log "${jid} ${plugin_name} kids number exceed,"\
			"[${kidsnum}] > [${KIDSNUM_UPLIMIT}], EXIT";
		process_kidsexceed "${plugin_name}" "${kidsnum}" "${KIDSNUM_UPLIMIT}"
		# update_lastrun_and_nextrun "${plugin_name}"		## no need, processed in process_kidsexceed()
		un_lock "${plugin_name}"	# unlock first
		del_fpid "${plugin_name}"	# then del pid file
		write_log ${jid} ${plugin_name}\
			"update lastrun time / release LOG / release runlock done. FINISHED.";
		unset _LOG
		return 1
  	else
		write_log ${jid} ${plugin_name} "eminfo kids number normal: [${kidsnum}] CONTINUE";
  	fi
  else
	write_log ${jid} ${plugin_name}\
		"eminfo pid file not exist or empty, SKIP max_kids_num check, CONTINUE"
  fi


  # Step 3: check if input plugin-name registered in config file or not
  write_log ${jid} ${plugin_name} "START";
  if [ -z "${plugin_name}" ]; then   ### plugin finished
	write_log ${jid} "plugin_name empty, please specify plugin_name. EXIT";
	update_status "${plugin_name}" "EXIT on Empty Plugin Name"
	update_lastrun_and_nextrun "${plugin_name}"
	un_lock "${plugin_name}"	# unlock first
	del_fpid "${plugin_name}"	# then del pid file
	unset _LOG
	return 1
  else
  	if [ "$(read_plugin_section "${plugin_name}" )" != "${plugin_name}" ]; then   ### plugin finished
		write_log ${jid} ${plugin_name} "not registered in config file. EXIT";
		update_status "${plugin_name}" "EXIT on Plugin NOT Registered";
		update_lastrun_and_nextrun "${plugin_name}"
		un_lock "${plugin_name}"	# unlock first
		del_fpid "${plugin_name}"	# then del pid file
		unset _LOG
		return 2
	else
		write_log ${jid} ${plugin_name} "registered in config file. CONTINUE";
	fi
  fi

  # Step 4: check if input plugin-name enabled in config file or not
  local status=$(get_enable "${plugin_name}")
  if [ "${status}" != "yes" ]; then	### plugin finished
	write_log ${jid} ${plugin_name} "not enabled."\
		"status=[${status}] EXIT";
	update_status "${plugin_name}" "EXIT on Plugin Disabled"
	update_lastrun_and_nextrun "${plugin_name}"
	un_lock "${plugin_name}"	# unlock first
	del_fpid "${plugin_name}"	# then del pid file
	unset _LOG
	return 0
  else
	write_log ${jid} ${plugin_name} "enabled. status=[${status}] CONTINUE";
  fi

  # Step 5: check if plugin file exists under PLUGIN_DIR or not
  if [ ! -f "${PLUGIN_DIR}/${plugin_name}" -o ! -s "${PLUGIN_DIR}/${plugin_name}" ]; then	### plugin finished
	write_log ${jid} ${plugin_name} "plugin file:"\
		"[${PLUGIN_DIR}/${plugin_name}] not exist or empty. EXIT";
	update_status "${plugin_name}" "EXIT on Plugin File Not Found or Empty"
	update_lastrun_and_nextrun "${plugin_name}"
	un_lock "${plugin_name}"	# unlock first
	del_fpid "${plugin_name}"	# then del pid file
	unset _LOG
	return 3
  else
	write_log ${jid} ${plugin_name} "plugin file:"\
		"[${PLUGIN_DIR}/${plugin_name}] exist -> exec. CONTINUE";
  fi

  # Step 6: exec plugin / obtain returned code / obtain returned stuff
  [ -x "${PLUGIN_DIR}/${plugin_name}" ] || {
	/bin/chmod a+x "${PLUGIN_DIR}/${plugin_name}" 2>&-
  }
  # local output=$( eval "..." 2>&1 )    # is wrong! can NOT get returned code, as be 0 always
  local output=  rc=
  output=$( eval "${PLUGIN_DIR}/${plugin_name}" 2>&1 )
  rc=$?
  write_log -f ${EMINFO_LOG} ${jid} ${plugin_name} "execution completed."\
	"return code: [${rc}]  return string: [${output}]. CONTINUE";

  # Step 6.1: check plugin output max length
  PLUGIN_MAXLEN=$( read_eminfo_config global plugin_maxlen )
  [ -z "${PLUGIN_MAXLEN}" -o ! -z "${PLUGIN_MAXLEN//[0-9]}" ] && PLUGIN_MAXLEN=65536
  local plugin_output_length="${#output}"
  if [ "$(echo  "${plugin_output_length} > $PLUGIN_MAXLEN" | bc 2>&-)" == "1" ]; then      ### truncate and plugin continue.
	write_log "${jid} ${plugin_name} plugin output length exceed,"\
		"[${plugin_output_length}] > [${PLUGIN_MAXLEN}], TRUNCATE";
	output="${output:0:${PLUGIN_MAXLEN}}"
	output="${output}}"		### completion '}' after truncated
	write_log "${jid} ${plugin_name} plugin output length exceed,"\
		"truncated result: [${output}], CONTINUE"
  else
	write_log ${jid} ${plugin_name} "plugin output length normal: [${plugin_output_length}] CONTINUE";
  fi

  # Step 6.2: check plugin return code
  case "${rc}" in
  "0"|"1"|"2"|"3"|"4")
	write_log ${jid} ${plugin_name} "plugin return code normal: [${rc}], CONTINUE";
	;;
  *)
	write_log ${jid} ${plugin_name} "plugin return code invalid: [${rc}], EXIT";  	  ### plugin finished
        process_plugin_exception "${plugin_name}"  "rc"  "${rc}"
        # update_lastrun_and_nextrun "${plugin_name}"		## no need, processed in process_plugin_exception()
        un_lock "${plugin_name}"        # unlock first
        del_fpid "${plugin_name}"       # then del pid file
        write_log ${jid} ${plugin_name}\
                "update lastrun time / release LOG / release runlock done. FINISHED.";
        unset _LOG
        return 1
	;;
  esac 

  # Step 6.3: check plugin output format

  # Step 6.3.1: check output lines number
  local output_linenum=
  output_linenum=$(echo -en "${output}"|awk 'END{print NR}')
  if [ "${output_linenum}" != "1" ]; then
        write_log "${jid} ${plugin_name} plugin output lines number invalid:"\
                "[${output_linenum}], should be one-line-output, EXIT";
	process_plugin_exception "${plugin_name}"  "lines"  "${output_linenum}"
        # update_lastrun_and_nextrun "${plugin_name}"    ## no need, processed in process_plugin_exception()
        un_lock "${plugin_name}"        # unlock first
        del_fpid "${plugin_name}"       # then del pid file
        write_log ${jid} ${plugin_name}\
                "update lastrun time / release LOG / release runlock done. FINISHED.";
        unset _LOG
        return 1
  else
        write_log ${jid} ${plugin_name} "plugin output lines number normal: [${output_linenum}] CONTINUE";
  fi

  # Step 6.3.2: check output parts format
  local part3=$( ${PLUTIL} "part_pstr_output" "3" "${output}" )
  if [ -z "${part3}" ]; then
        write_log "${jid} ${plugin_name} plugin output format unrecognized, EXIT";
	process_plugin_exception "${plugin_name}"  "format" "third part empty"
        # update_lastrun_and_nextrun "${plugin_name}"	   ## no need, processed in process_plugin_exception()
        un_lock "${plugin_name}"        # unlock first
        del_fpid "${plugin_name}"       # then del pid file
        write_log ${jid} ${plugin_name}\
                "update lastrun time / release LOG / release runlock done. FINISHED.";
        unset _LOG
        return 1
  else
	write_log ${jid} ${plugin_name} "plugin output format normal, CONTINUE";
  fi

  # Step 6.3.3: check output part1 -> {level}
  local part1=$( ${PLUTIL} "part_pstr_output" "1" "${output}" | tr '[A-Z]' '[a-z]' )
  case "${part1}" in
  "ok"|"warn"|"crit"|"unknown"|"noop")
	write_log ${jid} ${plugin_name} "plugin output level normal: [${part1}], CONTINUE";
	;;
  *)
	write_log ${jid} ${plugin_name} "plugin output level invalid: [${part1}], EXIT";	### plugin finished
	process_plugin_exception "${plugin_name}"  "level"  "${part1}"
        # update_lastrun_and_nextrun "${plugin_name}"   ## no need, processed in process_plugin_exception()
        un_lock "${plugin_name}"        # unlock first
        del_fpid "${plugin_name}"       # then del pid file
        write_log ${jid} ${plugin_name}\
                "update lastrun time / release LOG / release runlock done. FINISHED.";
        unset _LOG
        return 1
	;;
  esac

 # Step 6.3.4: check output part2 -> {type}
  local part2=$( ${PLUTIL} "part_pstr_output" "2" "${output}" | tr '[A-Z]' '[a-z]' )
  case "${part2}" in
  "file"|"str")
	write_log ${jid} ${plugin_name} "plugin output type normal: [${part2}], CONTINUE";
	;;
  *)
	write_log ${jid} ${plugin_name} "plugin output type invalid: [${part2}], EXIT";		### plugin finished
	process_plugin_exception "${plugin_name}"  "type"  "${part2}"
        # update_lastrun_and_nextrun "${plugin_name}"		## no need, processed in process_plugin_exception()
        un_lock "${plugin_name}"        # unlock first
        del_fpid "${plugin_name}"       # then del pid file
        write_log ${jid} ${plugin_name}\
                "update lastrun time / release LOG / release runlock done. FINISHED.";
        unset _LOG
        return 1
	;;
  esac
  

  # update plugin execution result
  update_status "${plugin_name}" "${output}"


  # Step 7: special steps.   
  # while plugin return status = 0(OK) or 4(NOOP)
  # return status: 0:OK  
  if [ "${rc}" == "0" ]; then    
	write_log ${jid} ${plugin_name}\
		"return status: [OK]. try to zero repeat errcount. CONTINUE";
	## reset accumulated return-err number => 0
	zero_repeat_errcount "${plugin_name}"
  # return status: 4:NOOP
  elif [ "${rc}" == "4" ]; then  ### plugin finished. 
	write_log ${jid} ${plugin_name}\
		"return status: [NOOP], Noting to do. EXIT";
	# update_status "${plugin_name}" "EXIT on Plugin Return NOOP"
	update_lastrun_and_nextrun "${plugin_name}"
	un_lock "${plugin_name}"	# unlock first
	del_fpid "${plugin_name}"	# then del pid file
	write_log ${jid} ${plugin_name}\
		"update lastrun time / release LOG / release runlock done. FINISHED.";
	unset _LOG
	return 0
  # return status: (1/2/3) == (! 0/4)
  else  
	write_log ${jid} ${plugin_name}\
		"return code: [${rc}]. try to +1 on repeat errcount. CONTINUE";
	### accumulated error number +1
  	add_repeat_errcount "${plugin_name}"
  	local array_repeat_err_stuff=()
  	array_repeat_err_stuff=( $(check_repeat_errcount ${plugin_name}) )
  	local _yes_ornot=${array_repeat_err_stuff[0]} 
	local _now_errcount=${array_repeat_err_stuff[1]} 
	local _errcount_uplimit=${array_repeat_err_stuff[2]}
  	if [ "${_yes_ornot}" == "1" ]; then  # plugin continue
		write_log ${jid} ${plugin_name} "reached maximize errtimes:"\
			"[(${_now_errcount}) >= (${_errcount_uplimit})] CONTINUE";
  	else  # plugin finished
		write_log ${jid} ${plugin_name} "have-not-yet reached maximize errtimes:"\
			"[(${_now_errcount}) < (${_errcount_uplimit})] EXIT";
		# update_status "${plugin_name}" "EXIT on Not Reached MaxErr Limit"
        	update_lastrun_and_nextrun "${plugin_name}"
        	un_lock "${plugin_name}"	# unlock first
        	del_fpid "${plugin_name}"	# then del pid file
        	write_log ${jid} ${plugin_name}\
			"update lastrun time / release LOG / release runlock done. FINISHED.";
        	unset _LOG
        	return 0
  	fi
  fi

  # Step 8: check action: take_snapshot
  local t_snap=$(take_action_ornot "${plugin_name}" take_snapshot ${rc})
  if [ "${t_snap}" != "yes" ]; then
	write_log ${jid} ${plugin_name} "take snapshot disabled. SKIP";
  else
	write_log ${jid} ${plugin_name} "take snapshot enabled. CONTINUE";
	${TAKESNAP_SH} -f "${plugin_name}" -s "${jid}" 1>/dev/null 2>&1
	write_log ${jid} ${plugin_name} "take snapshot finished."\
		"detailis in ${TAKESNAP_LOG##*/}. CONTINUE";
  fi
	
  # Step 9: check action: auto_handle
  local a_hand=$(take_action_ornot "${plugin_name}" auto_handle ${rc})
  local hd_output=  hd_rc=
  if [ "${a_hand}" != "yes" ]; then
	write_log ${jid} ${plugin_name} "auto handle disabled. SKIP";
	hd_output="auto handle is disabled. Nothing to do"
  else
	write_log ${jid} ${plugin_name} "auto handle enabled. CONTINUE";
	local handler=$(get_auto_handler "${plugin_name}")
	if [ -f "${HANDLER_DIR}/${handler}" -a -s "${HANDLER_DIR}/${handler}" ]; then
		write_log ${jid} ${plugin_name} "auto handler:"\
			"[${HANDLER_DIR}/${handler}] exists. CONTINUE";
 		[ ! -x "${HANDLER_DIR}/${handler}" ] && /bin/chmod a+x "${HANDLER_DIR}/${handler}" 2>&-
		hd_output=$( eval "${HANDLER_DIR}/${handler}" 2>&1 )
		hd_rc=$?
		write_log ${jid} ${plugin_name} "auto handler execution completed."\
			"return code:[${hd_rc}] return string: [${hd_output}] CONTINUE";
		HANDLER_MAXLEN=$( read_eminfo_config global handler_maxlen )
		[ -z "${HANDLER_MAXLEN}" -o ! -z "${HANDLER_MAXLEN//[0-9]}" ] && PLUGIN_MAXLEN=32768
		local handler_output_length="${#hd_output}"
  		if [ "$(echo  "${handler_output_length} > $HANDLER_MAXLEN" | bc 2>&-)" == "1" ]; then  ### truncate it
        		write_log "${jid} ${plugin_name} handler output length exceed,"\
                		"[${handler_output_length}] > [${HANDLER_MAXLEN}], TRUNCATE";
        		hd_output="${hd_output:0:${HANDLER_MAXLEN}}"
        		hd_output="${hd_output}}"             ### completion '}' after truncated
        		write_log "${jid} ${plugin_name} handler output length exceed,"\
                		"truncated result: [${hd_output}], CONTINUE"
  		else 
        		write_log "${jid} ${plugin_name} handler output length normal: [${handler_output_length}] CONTINUE";
  		fi
		hd_output="auto handler [${HANDLER_DIR}/${handler}] return ### ### [${hd_output}]"
  	else
		write_log ${jid} ${plugin_name} "auto handler:"\
			"[${HANDLER_DIR}/${handler}] not exist or empty. SKIP";
		hd_output="auto handler [${HANDLER_DIR}/${handler}] not exist or empty. Nothing to do"
	fi
  fi

  # Step 10: check action: post_notify
  local p_alert=$(take_action_ornot "${plugin_name}" post_notify ${rc})
  if [ "${p_alert}" != "yes" ]; then
	write_log ${jid} ${plugin_name} "post notify disabled. SKIP";
  else
	write_log ${jid} ${plugin_name} "post notify enabled. CONTINUE";
	# eval  will return syntax error. why ?
	${POSTLOG_SH} -f "${plugin_name}" -s "${jid}" -i "${output}" -h "${hd_output}" 2>&1
	write_log ${jid} ${plugin_name} "post notify finished."\
		"details in ${POSTLOG_LOG##*/}. CONTINUE";
  fi

  # Step 11: check action: mail_notify
  local m_alert=$(take_action_ornot "${plugin_name}" mail_notify ${rc})
  if [ "${m_alert}" != "yes" ]; then
	write_log ${jid} ${plugin_name} "mail notify disabled. SKIP";
  else
	write_log ${jid} ${plugin_name} "mail notify enabled. CONTINUE";
	# eval  will return syntax error. why ?
	${SENDMAIL} -f "${plugin_name}" -s "${jid}" -i "${output}" -h "${hd_output}"
	write_log ${jid} ${plugin_name} "mail notify finished."\
		"details in ${SENDMAIL_LOG##*/}. CONTINUE";
  fi

  # Step 12: plugin finished
  update_lastrun_and_nextrun "${plugin_name}"
  un_lock "${plugin_name}"   # unlock first
  del_fpid "${plugin_name}"  # then del pid file
  write_log ${jid} ${plugin_name}\
	"update lastrun time / release LOG / release runlock done. FINISHED";
  unset _LOG
  return 0
}



# Process inner plugin, in fact simplified version of process_plugin
# Usage:	process_inner_plugin    plugin_name 
#
process_inner_plugin() {
  local plugin_name=$1  mode=$2 output=

  # Step 1: set random/unique jid
  local jid=$(/bin/mktemp -u XXXXXXXX 2>&-) 

  # Step 2: check plugin script 
  write_log -f ${INNER_LOG} ${jid} ${plugin_name} "START"
  if [ ! -f "${INNER_DIR}/${plugin_name}" ]; then
        write_log -f ${INNER_LOG} ${jid} ${plugin_name} "plugin file:"\
		"[${INNER_DIR}/${plugin_name}] not exist. EXIT";
        del_fpid "${plugin_name}"
        [ "${mode}" == "startrun" ] || un_lock "${plugin_name}"
        return 3
  else
        write_log -f ${INNER_LOG} ${jid} ${plugin_name} "plugin file:"\
		"[${INNER_DIR}/${plugin_name}] exist -> exec. CONTINUE";
  fi

  # Step 3: execute plugin / get return stuff
  [ ! -x "${INNER_DIR}/${plugin_name}" ] && /bin/chmod a+x "${INNER_DIR}/${plugin_name}"
  output=$( eval "${INNER_DIR}/${plugin_name}" 2>&1 )
  write_log -f ${INNER_LOG} ${jid} ${plugin_name} "execution completed."\
	"return: [${output}]";

 # Step 4: plugin finished
 update_status "${plugin_name}" "${output}"
 update_lastrun_and_nextrun "${plugin_name}"
 [ "${mode}" == "startrun" ] || un_lock "${plugin_name}"	# unlock first
 del_fpid "${plugin_name}"					# then del pid file
 write_log -f ${INNER_LOG} ${jid} ${plugin_name} "execution DONE."

}

# Process plugin running timeout
# Usage:    	process_plugin_timeout   plugin_name
# LogFlag: 	TMT00000
# 
process_plugin_timeout() {
  local plugin_name=$1
  local output="{tmout}:{str}:{ Plugin Execution TimeOut"\
"| ${plugin_name} has been cancled at $(date +%F_%T)"\
"| $(html_red "Plugin: [${plugin_name}] execution timeout, has been terminated.") ### }";

  # Step 0: update status
  update_status "${plugin_name}" "${output}"

  # Step 1: update lastrun and nextrun
  update_lastrun_and_nextrun "${plugin_name}"

  # Step 2: stop timeout plugin 
  stop_single_plugin "${plugin_name}"
  # return here while inner plugin
  [ "$( echo "${plugin_name}" | grep -E -o "^eminfo_" )" != "" ] && return 0

  # Step 2: take snapshot
  local t_snap=$(take_action_ornot "${plugin_name}" take_snapshot tmout)
  if [ "${t_snap}" != "yes" ]; then
        write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} take snapshot disabled. SKIP";
  else
        write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} take snapshot enabled. CONTINUE";
        ${TAKESNAP_SH} -f "${plugin_name}" -s "tmout" 1>/dev/null 2>&1
        write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} take snapshot finished."\
		"detailis in ${TAKESNAP_LOG##*/}. CONTINUE";
  fi

  # Step 3: auto handler while timeout
  local a_hand=$(take_action_ornot "${plugin_name}" auto_handle "tmout")
  local hd_output=  hd_rc=
  if [ "${a_hand}" != "yes" ]; then
 	write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} auto handle disabled. SKIP";
	hd_output="auto handle is disabled. Nothing to do"
  else
	write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} auto handle enabled. CONTINUE";
	local handler=$(get_auto_handler "${plugin_name}")
        if [ -f "${HANDLER_DIR}/${handler}" -a -s "${HANDLER_DIR}/${handler}" ]; then
                write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} auto handler:"\
			"[${HANDLER_DIR}/${handler}] exists. CONTINUE";
                [ ! -x "${HANDLER_DIR}/${handler}" ] && /bin/chmod a+x "${HANDLER_DIR}/${handler}" 2>&-
		hd_output=$( eval "${HANDLER_DIR}/${handler}" 2>&1 )
		hd_rc=$?
                write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} auto handle execution completed."\
			"return code:[${hd_rc}] return string: [${hd_output}] CONTINUE";
                HANDLER_MAXLEN=$( read_eminfo_config global handler_maxlen )
                [ -z "${HANDLER_MAXLEN}" -o ! -z "${HANDLER_MAXLEN//[0-9]}" ] && PLUGIN_MAXLEN=32768
                local handler_output_length="${#hd_output}"
                if [ "$(echo  "${handler_output_length} > $HANDLER_MAXLEN" | bc 2>&-)" == "1" ]; then  ### truncate it
                        write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} handler output length exceed,"\
                                "[${handler_output_length}] > [${HANDLER_MAXLEN}], TRUNCATE";
                        hd_output="${hd_output:0:${HANDLER_MAXLEN}}"
                        hd_output="${hd_output}}"             ### completion '}' after truncated
                        write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} handler output length exceed,"\
                                "truncated result: [${hd_output}], CONTINUE"
                else 
			write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} handler output length normal: [${handler_output_length}] CONTINUE";
                fi   
		hd_output="auto handler file [${HANDLER_DIR}/${handler}] return ### ### [${hd_output}]"
        else
                write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} auto handler:"\
			"[${HANDLER_DIR}/${handler}] not exist or empty. SKIP";
		hd_output="auto handler file [${HANDLER_DIR}/${handler}] not exist or empty. Nothing to do"
        fi
  fi

  # Step 4: post timeout information
  local p_alert=$(take_action_ornot "${plugin_name}" post_notify "tmout")
  if [ "${p_alert}" != "yes" ]; then
        write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} post notify disabled. SKIP";
  else
        write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} post notify enabled. CONTINUE";
        ${POSTLOG_SH} -f "${plugin_name}" -s "tmout" -i "${output}" -h "${hd_output}" 2>&1 # eval will return syntax error. why?
        write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} post alert finished."\
		"details in ${POSTLOG_LOG##*/}. CONTINUE";
  fi

  # Step 5: send timeout notify mail
  local m_alert=$(take_action_ornot "${plugin_name}" mail_notify "tmout")
  if [ "${m_alert}" != "yes" ]; then
        write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} mail notify disabled. SKIP";
  else
	write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} mail notify enabled. CONTINUE";
	${SENDMAIL} -f "${plugin_name}" -s "tmout" -i "${output}" -h "${hd_output}"
	write_log -f "${EMINFO_LOG}" "TMT00000 ${plugin_name} send timeout mail:"\
		"finished. details in ${SENDMAIL_LOG##*/}. CONTINUE";
  fi


}

# Process system overloaded
# Usage:    	process_sysoverload  plugin-name   sysload_now  sysload_limit
# Example:	process_sysoverload  check_smtp_svr  39  30
# LogFlag: 	OVLD0000
# 
process_sysoverload() {
  local plugin_name=$1  sysload_now=$2  sysload_limit=$3
  local output="{ovld}:{str}:{ System OverLoad"\
"| ${plugin_name} has been cancled at $(date +%F_%T)"\
"| $(html_red "Sysload: [${sysload_now}] over than Uplimit: [${sysload_limit}]") ### "\
"Plugin: [${plugin_name}] has been cancled ### }";
  local hd_output="System OverLoaded, Nothing to do"

  # Step 0: update status.
  update_status "${plugin_name}" "${output}"

  # Step 1: update lastrun and nextrun.
  update_lastrun_and_nextrun "${plugin_name}"

  # Step 2: take snapshot whatever.
  write_log -f "${EMINFO_LOG}" "OVLD0000 EMINFO sysload overloaded:"\
	"[${sysload_now} >= ${sysload_limit}] 1 => taking snapshot";
  ${TAKESNAP_SH} -f "${plugin_name}" -s "ovld" >/dev/null 2>&1

  # Step 2: send alert mail whatever.
  write_log -f "${EMINFO_LOG}" "OVLD0000 EMINFO sysload overloaded:"\
	"[${sysload_now} >= ${sysload_limit}] 2 => sending alert mail";
  ${SENDMAIL} -f "${plugin_name}" -s "ovld" -i "${output}" -h "${hd_output}"

  # Step 3: post alert information whatever.
  write_log -f "${EMINFO_LOG}" "OVLD0000 EMINFO sysload overloaded:"\
	"[${sysload_now} >= ${sysload_limit}] 3 => posting alert data";
  ${POSTLOG_SH} -f "${plugin_name}" -s "ovld" -i "${output}" -h "${hd_output}" 2>&1
}


# Process system overloaded
# Usage:    	process_kidsexceed plugin-name   kidsnum_now  kidsnum_limit
# Example:	process_kidsexceed check_smtp_svr  32  30
# LogFlag: 	KIDS0000
# 
process_kidsexceed() {
  local plugin_name=$1  kidsnum_now=$2  kidsnum_limit=$3
  local output="{kids}:{str}:{ Too Many Kid Processes"\
"| ${plugin_name} has been cancled at $(date +%F_%T)"\
"| $(html_red "Kids Running: [${kidsnum_now}] over than Uplimit: [${kidsnum_limit}]") ### "\
"Plugin: [${plugin_name}] has been cancled ### }";
  local hd_output="Kid Processes Number Exceed, Nothing to do"

  # Step 0: update status.
  update_status "${plugin_name}" "${output}"

  # Step 1: update lastrun and nextrun.
  update_lastrun_and_nextrun "${plugin_name}"

  # Step 2: take snapshot whatever.
  write_log -f "${EMINFO_LOG}" "KIDS0000 EMINFO kidsnum exceed:"\
	"[${kidsnum_now} >= ${kidsnum_limit}] 1 => taking snapshot";
  ${TAKESNAP_SH} -f "${plugin_name}" -s "kids" >/dev/null 2>&1

  # Step 3: send alert mail whatever.
  write_log -f "${EMINFO_LOG}" "KIDS0000 EMINFO kidsnum exceed:"\
	"[${kidsnum_now} >= ${kidsnum_limit}] 2 => sending alert mail";
  ${SENDMAIL} -f "${plugin_name}" -s "kids" -i "${output}" -h "${hd_output}"

  # Step 4: post alert information whatever.
  write_log -f "${EMINFO_LOG}" "KIDS0000 EMINFO kidsnum exceed:"\
	"[${kidsnum_now} >= ${kidsnum_limit}] 3 => posting alert data";
  ${POSTLOG_SH} -f "${plugin_name}" -s "kids" -i "${output}" -h "${hd_output}" 2>&1
}

# Process plugin exception rcode/output
# Usage:	process_plugin_exception {plugin-name}  {reason_type}  {reason_value}
# Note:		reason_type	~  rc|lines|format|level|type
# Example:	process_plugin_exception sysload  rc  9
# LogFlag:	MISF0000
#
process_plugin_exception() {
  local plugin_name=$1  reason_type=$2  reason_value=$3 
  local reason=
  case "${reason_type}" in
  "rc") 
	reason="plugin return code invalid: [${reason_value}], only 0-4 allowed"
	;;
  "lines")
	reason="plugin output lines number invalid: [${reason_value}], only one-line allowed"
	;;
  "format")
	reason="plugin output format unrecognized: [${reason_value}], only {a}:{b}:{c} allowed"
	;;
  "level")
	reason="plugin output level unrecognized: [${reason_value}], only [ok,warn,crit,unknown,noop] allowed"
	;;
  "type")
	reason="plugin output type unrecognized: [${reason_value}], only [file,str] allowed"
	;;
  esac
  local output="{misform}:{str}:{ Misforma Plugin Output"\
"| ${plugin_name} has been cancled at $(date +%F_%T)"\
"| plugin ${plugin_name} output misforma on [${reason_type}] ### "\
"$(html_red "${reason}") ### }";
  local hd_output="Plugin Output Misform, Nothing to do"

  # Step 0: update status.
  update_status "${plugin_name}" "${output}"

  # Step 1: update lastrun and nextrun.
  update_lastrun_and_nextrun "${plugin_name}"

  # Step 2: send misforma notify-mail or not ?
  local notify_onmisform=$(read_eminfo_config global notify_onmisform)
  [ -z "${notify_onmisform}" ] && notify_onmisform="yes"
  if [ "${notify_onmisform}" == "yes" ]; then
  	write_log -f "${EMINFO_LOG}" "MISF0000 EMINFO output misforma:"\
        	"[${reason}] 1 => sending notify mail";
  	${SENDMAIL} -f "${plugin_name}" -s "misf" -i "${output}" -h "${hd_output}"
  else
	write_log -f "${EMINFO_LOG}" "MISF0000 EMINFO output misforma:"
		"[${reason}] 1 => send notify mail disabled, SKIP" 
  fi

  # Step 3: post misforma information whatever.
  write_log -f "${EMINFO_LOG}" "MISF0000 EMINFO output misforma:"\
        "[${reason}] 2 => posting notify data";
  ${POSTLOG_SH} -f "${plugin_name}" -s "misf" -i "${output}" -h "${hd_output}" 2>&1

}



#################  Debug Area  #####################



# read_eminfo_config check_v5_mailq notify_alert
# read_eminfo_config default notify_alert
# read_eminfo_config global name

# plugin_name="check_pop_svr"

# get_pidkids_bypid 1
# get_kidsnum 1177
# stopps_by_pidfile  /tmp/1.pid
# stopps_by_pidfile /bak/workdir/eminfo/tmp/run/check_sysload.pid
# stopps_by_pidfile /var/run/sshd.pid
# list_plugin_section
# list_inner_plugin_section
# update_lastrun_and_nextrun  "check_sysload **&*())_   ^^%"
# list_plugin_status  1 2 
# check_ps_by_pid_file /tmp/1.pid
# process_plugin_timeout   check_sysload
# check_repeat_errcount  check_sysload
# check_repeat_errcount  hello
# add_repeat_errcount  check_sysload
# add_repeat_errcount  hello
# add_repeat_errcount  "hello2 123 ()"
# zero_repeat_errcount  check_sysload
# gen_tmpfile check_sysload
# list_enabled_plugin_section
# gen_lock check_disk_freespace
# gen_lock eminfo_log_rotate
# clear_dead_lock_pid check_disk_freespace
# clear_dead_lock_pid eminfo_log_rotate
# list_running_plugin_section
# check_lock   check_sysload
# sub_str "${TMP_DIR}" "eminfo/tmp"
# sub_str "${BACK_DIR}" "eminfo/log/backup"
# sub_str "${SNAPSHOT_DIR}" "eminfo/log/snapshot" 
# sub_str "/bin/" "/bin/"

# conv_2realpath "eminfo/log/backup" ; echo $?
# conv_2realpath "/usr/lib/sendmail.sendmail" ; echo $?
# conv_2realpath "/etc/rc" ; echo $?

# py_conv_2realpath "/usr/local/eyou/mail/tmp/phello/phello/etc/eyou_mail.ini"
# py_conv_2realpath "eminfo/log/backup"
# py_conv_2realpath "/usr/lib/sendmail.sendmail"
# py_conv_2realpath "/tmp/1/1"

# get_mail_receviers default
# get_mail_receviers notify_syslogin


# sed -e 's/<[^<^>]*>//g; s/&nbsp;//g; s/###/\n/g;';
# view_base_config report_sysinfo 
# view_extra_config port  1
# view_extra_config port  

# get_enable default 
# get_maxerr_times check_default

# get_frequency check_sysload

# get_action_type check_sysload post_notify1
# conv_time2sec 1800sec

# update_status report_sysinfo "{ok}:{file}:{/var/log/secure_report.2013.4.10.csv /var/log/secure /etc/passwd /tmp/.hack.tgz}"

# update_eminfo_config check_sysload enable yes
# echo $?
# add_eminfo_config hello hey "renchaoqi@eyou.net file:opt/receviers 1278098"
# echo $?
# update_eminfo_config hello hey "a&(*() $%%^&&**"
# echo $?
# add_eminfo_config check_sysload enable no
# echo $?
# del_eminfo_config check_sysload enable
# echo $?
# del_eminfo_config hello enable
# echo $?

# enable_plugin  check_sysload
# echo $?
# disable_plugin check_sysload
# echo $?
# disable_plugin check_sysload
# echo $?
